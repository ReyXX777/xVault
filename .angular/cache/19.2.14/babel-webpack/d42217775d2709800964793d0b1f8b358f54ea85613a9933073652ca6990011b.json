{"ast":null,"code":"import _asyncToGenerator from \"X:/secure-messenger/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\r\n * @license Angular v19.2.14\r\n * (c) 2010-2025 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\n\nimport { PLATFORM_SERVER_PROVIDERS, PlatformState, BEFORE_APP_SERIALIZED, platformServer, INITIAL_CONFIG, createScript } from './server-_br4z1cG.mjs';\nexport { ServerModule, DominoAdapter as ɵDominoAdapter, ENABLE_DOM_EMULATION as ɵENABLE_DOM_EMULATION, INTERNAL_SERVER_PLATFORM_PROVIDERS as ɵINTERNAL_SERVER_PLATFORM_PROVIDERS, SERVER_RENDER_PROVIDERS as ɵSERVER_RENDER_PROVIDERS } from './server-_br4z1cG.mjs';\nimport { makeEnvironmentProviders, InjectionToken, ɵstartMeasuring as _startMeasuring, ɵstopMeasuring as _stopMeasuring, ApplicationRef, ɵIS_HYDRATION_DOM_REUSE_ENABLED as _IS_HYDRATION_DOM_REUSE_ENABLED, ɵannotateForHydration as _annotateForHydration, CSP_NONCE, APP_ID, Renderer2, ɵSSR_CONTENT_INTEGRITY_MARKER as _SSR_CONTENT_INTEGRITY_MARKER, Version } from '@angular/core';\nimport '@angular/common';\nimport '@angular/platform-browser';\nimport '@angular/common/http';\nimport 'rxjs';\n\n/**\r\n * Sets up providers necessary to enable server rendering functionality for the application.\r\n *\r\n * @usageNotes\r\n *\r\n * Basic example of how you can add server support to your application:\r\n * ```ts\r\n * bootstrapApplication(AppComponent, {\r\n *   providers: [provideServerRendering()]\r\n * });\r\n * ```\r\n *\r\n * @publicApi\r\n * @returns A set of providers to setup the server.\r\n */\nfunction provideServerRendering() {\n  if (typeof ngServerMode === 'undefined') {\n    globalThis['ngServerMode'] = true;\n  }\n  return makeEnvironmentProviders([...PLATFORM_SERVER_PROVIDERS]);\n}\n\n/**\r\n * Event dispatch (JSAction) script is inlined into the HTML by the build\r\n * process to avoid extra blocking request on a page. The script looks like this:\r\n * ```html\r\n * <script type=\"text/javascript\" id=\"ng-event-dispatch-contract\">...</script>\r\n * ```\r\n * This const represents the \"id\" attribute value.\r\n */\nconst EVENT_DISPATCH_SCRIPT_ID = 'ng-event-dispatch-contract';\n/**\r\n * Creates an instance of a server platform (with or without JIT compiler support\r\n * depending on the `ngJitMode` global const value), using provided options.\r\n */\nfunction createServerPlatform(options) {\n  const extraProviders = options.platformProviders ?? [];\n  const measuringLabel = 'createServerPlatform';\n  _startMeasuring(measuringLabel);\n  const platform = platformServer([{\n    provide: INITIAL_CONFIG,\n    useValue: {\n      document: options.document,\n      url: options.url\n    }\n  }, extraProviders]);\n  _stopMeasuring(measuringLabel);\n  return platform;\n}\n/**\r\n * Finds and returns inlined event dispatch script if it exists.\r\n * See the `EVENT_DISPATCH_SCRIPT_ID` const docs for additional info.\r\n */\nfunction findEventDispatchScript(doc) {\n  return doc.getElementById(EVENT_DISPATCH_SCRIPT_ID);\n}\n/**\r\n * Removes inlined event dispatch script if it exists.\r\n * See the `EVENT_DISPATCH_SCRIPT_ID` const docs for additional info.\r\n */\nfunction removeEventDispatchScript(doc) {\n  findEventDispatchScript(doc)?.remove();\n}\n/**\r\n * Annotate nodes for hydration and remove event dispatch script when not needed.\r\n */\nfunction prepareForHydration(platformState, applicationRef) {\n  const measuringLabel = 'prepareForHydration';\n  _startMeasuring(measuringLabel);\n  const environmentInjector = applicationRef.injector;\n  const doc = platformState.getDocument();\n  if (!environmentInjector.get(_IS_HYDRATION_DOM_REUSE_ENABLED, false)) {\n    // Hydration is diabled, remove inlined event dispatch script.\n    // (which was injected by the build process) from the HTML.\n    removeEventDispatchScript(doc);\n    return;\n  }\n  appendSsrContentIntegrityMarker(doc);\n  const eventTypesToReplay = _annotateForHydration(applicationRef, doc);\n  if (eventTypesToReplay.regular.size || eventTypesToReplay.capture.size) {\n    insertEventRecordScript(environmentInjector.get(APP_ID), doc, eventTypesToReplay, environmentInjector.get(CSP_NONCE, null));\n  } else {\n    // No events to replay, we should remove inlined event dispatch script\n    // (which was injected by the build process) from the HTML.\n    removeEventDispatchScript(doc);\n  }\n  _stopMeasuring(measuringLabel);\n}\n/**\r\n * Creates a marker comment node and append it into the `<body>`.\r\n * Some CDNs have mechanisms to remove all comment node from HTML.\r\n * This behaviour breaks hydration, so we'll detect on the client side if this\r\n * marker comment is still available or else throw an error\r\n */\nfunction appendSsrContentIntegrityMarker(doc) {\n  // Adding a ng hydration marker comment\n  const comment = doc.createComment(_SSR_CONTENT_INTEGRITY_MARKER);\n  doc.body.firstChild ? doc.body.insertBefore(comment, doc.body.firstChild) : doc.body.append(comment);\n}\n/**\r\n * Adds the `ng-server-context` attribute to host elements of all bootstrapped components\r\n * within a given application.\r\n */\nfunction appendServerContextInfo(applicationRef) {\n  const injector = applicationRef.injector;\n  let serverContext = sanitizeServerContext(injector.get(SERVER_CONTEXT, DEFAULT_SERVER_CONTEXT));\n  applicationRef.components.forEach(componentRef => {\n    const renderer = componentRef.injector.get(Renderer2);\n    const element = componentRef.location.nativeElement;\n    if (element) {\n      renderer.setAttribute(element, 'ng-server-context', serverContext);\n    }\n  });\n}\nfunction insertEventRecordScript(appId, doc, eventTypesToReplay, nonce) {\n  const measuringLabel = 'insertEventRecordScript';\n  _startMeasuring(measuringLabel);\n  const {\n    regular,\n    capture\n  } = eventTypesToReplay;\n  const eventDispatchScript = findEventDispatchScript(doc);\n  // Note: this is only true when build with the CLI tooling, which inserts the script in the HTML\n  if (eventDispatchScript) {\n    // This is defined in packages/core/primitives/event-dispatch/contract_binary.ts\n    const replayScriptContents = `window.__jsaction_bootstrap(` + `document.body,` + `\"${appId}\",` + `${JSON.stringify(Array.from(regular))},` + `${JSON.stringify(Array.from(capture))}` + `);`;\n    const replayScript = createScript(doc, replayScriptContents, nonce);\n    // Insert replay script right after inlined event dispatch script, since it\n    // relies on `__jsaction_bootstrap` to be defined in the global scope.\n    eventDispatchScript.after(replayScript);\n  }\n  _stopMeasuring(measuringLabel);\n}\n/**\r\n * Renders an Angular application to a string.\r\n *\r\n * @private\r\n *\r\n * @param platformRef - Reference to the Angular platform.\r\n * @param applicationRef - Reference to the Angular application.\r\n * @returns A promise that resolves to the rendered string.\r\n */\nfunction renderInternal(_x, _x2) {\n  return _renderInternal.apply(this, arguments);\n}\n/**\r\n * Destroy the application in a macrotask, this allows pending promises to be settled and errors\r\n * to be surfaced to the users.\r\n */\nfunction _renderInternal() {\n  _renderInternal = _asyncToGenerator(function* (platformRef, applicationRef) {\n    const platformState = platformRef.injector.get(PlatformState);\n    prepareForHydration(platformState, applicationRef);\n    appendServerContextInfo(applicationRef);\n    // Run any BEFORE_APP_SERIALIZED callbacks just before rendering to string.\n    const environmentInjector = applicationRef.injector;\n    const callbacks = environmentInjector.get(BEFORE_APP_SERIALIZED, null);\n    if (callbacks) {\n      const asyncCallbacks = [];\n      for (const callback of callbacks) {\n        try {\n          const callbackResult = callback();\n          if (callbackResult) {\n            asyncCallbacks.push(callbackResult);\n          }\n        } catch (e) {\n          // Ignore exceptions.\n          console.warn('Ignoring BEFORE_APP_SERIALIZED Exception: ', e);\n        }\n      }\n      if (asyncCallbacks.length) {\n        for (const result of yield Promise.allSettled(asyncCallbacks)) {\n          if (result.status === 'rejected') {\n            console.warn('Ignoring BEFORE_APP_SERIALIZED Exception: ', result.reason);\n          }\n        }\n      }\n    }\n    return platformState.renderToString();\n  });\n  return _renderInternal.apply(this, arguments);\n}\nfunction asyncDestroyPlatform(platformRef) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      platformRef.destroy();\n      resolve();\n    }, 0);\n  });\n}\n/**\r\n * Specifies the value that should be used if no server context value has been provided.\r\n */\nconst DEFAULT_SERVER_CONTEXT = 'other';\n/**\r\n * An internal token that allows providing extra information about the server context\r\n * (e.g. whether SSR or SSG was used). The value is a string and characters other\r\n * than [a-zA-Z0-9\\-] are removed. See the default value in `DEFAULT_SERVER_CONTEXT` const.\r\n */\nconst SERVER_CONTEXT = /*#__PURE__*/new InjectionToken('SERVER_CONTEXT');\n/**\r\n * Sanitizes provided server context:\r\n * - removes all characters other than a-z, A-Z, 0-9 and `-`\r\n * - returns `other` if nothing is provided or the string is empty after sanitization\r\n */\nfunction sanitizeServerContext(serverContext) {\n  const context = serverContext.replace(/[^a-zA-Z0-9\\-]/g, '');\n  return context.length > 0 ? context : DEFAULT_SERVER_CONTEXT;\n}\n/**\r\n * Bootstraps an application using provided NgModule and serializes the page content to string.\r\n *\r\n * @param moduleType A reference to an NgModule that should be used for bootstrap.\r\n * @param options Additional configuration for the render operation:\r\n *  - `document` - the document of the page to render, either as an HTML string or\r\n *                 as a reference to the `document` instance.\r\n *  - `url` - the URL for the current render request.\r\n *  - `extraProviders` - set of platform level providers for the current render request.\r\n *\r\n * @publicApi\r\n */\nfunction renderModule(_x3, _x4) {\n  return _renderModule.apply(this, arguments);\n}\n/**\r\n * Bootstraps an instance of an Angular application and renders it to a string.\r\n\r\n * ```ts\r\n * const bootstrap = () => bootstrapApplication(RootComponent, appConfig);\r\n * const output: string = await renderApplication(bootstrap);\r\n * ```\r\n *\r\n * @param bootstrap A method that when invoked returns a promise that returns an `ApplicationRef`\r\n *     instance once resolved.\r\n * @param options Additional configuration for the render operation:\r\n *  - `document` - the document of the page to render, either as an HTML string or\r\n *                 as a reference to the `document` instance.\r\n *  - `url` - the URL for the current render request.\r\n *  - `platformProviders` - the platform level providers for the current render request.\r\n *\r\n * @returns A Promise, that returns serialized (to a string) rendered page, once resolved.\r\n *\r\n * @publicApi\r\n */\nfunction _renderModule() {\n  _renderModule = _asyncToGenerator(function* (moduleType, options) {\n    const {\n      document,\n      url,\n      extraProviders: platformProviders\n    } = options;\n    const platformRef = createServerPlatform({\n      document,\n      url,\n      platformProviders\n    });\n    try {\n      const moduleRef = yield platformRef.bootstrapModule(moduleType);\n      const applicationRef = moduleRef.injector.get(ApplicationRef);\n      const measuringLabel = 'whenStable';\n      _startMeasuring(measuringLabel);\n      // Block until application is stable.\n      yield applicationRef.whenStable();\n      _stopMeasuring(measuringLabel);\n      return yield renderInternal(platformRef, applicationRef);\n    } finally {\n      yield asyncDestroyPlatform(platformRef);\n    }\n  });\n  return _renderModule.apply(this, arguments);\n}\nfunction renderApplication(_x5, _x6) {\n  return _renderApplication.apply(this, arguments);\n}\n/**\r\n * @module\r\n * @description\r\n * Entry point for all public APIs of the platform-server package.\r\n */\n/**\r\n * @publicApi\r\n */\nfunction _renderApplication() {\n  _renderApplication = _asyncToGenerator(function* (bootstrap, options) {\n    const renderAppLabel = 'renderApplication';\n    const bootstrapLabel = 'bootstrap';\n    const _renderLabel = '_render';\n    _startMeasuring(renderAppLabel);\n    const platformRef = createServerPlatform(options);\n    try {\n      _startMeasuring(bootstrapLabel);\n      const applicationRef = yield bootstrap();\n      _stopMeasuring(bootstrapLabel);\n      _startMeasuring(_renderLabel);\n      const measuringLabel = 'whenStable';\n      _startMeasuring(measuringLabel);\n      // Block until application is stable.\n      yield applicationRef.whenStable();\n      _stopMeasuring(measuringLabel);\n      const rendered = yield renderInternal(platformRef, applicationRef);\n      _stopMeasuring(_renderLabel);\n      return rendered;\n    } finally {\n      yield asyncDestroyPlatform(platformRef);\n      _stopMeasuring(renderAppLabel);\n    }\n  });\n  return _renderApplication.apply(this, arguments);\n}\nconst VERSION = /*#__PURE__*/new Version('19.2.14');\nexport { BEFORE_APP_SERIALIZED, INITIAL_CONFIG, PlatformState, VERSION, platformServer, provideServerRendering, renderApplication, renderModule, SERVER_CONTEXT as ɵSERVER_CONTEXT, renderInternal as ɵrenderInternal };\n//# sourceMappingURL=platform-server.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}