{"ast":null,"code":"import _asyncToGenerator from \"X:/secure-messenger/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _wrapAsyncGenerator from \"X:/secure-messenger/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _awaitAsyncGenerator from \"X:/secure-messenger/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _asyncGeneratorDelegate from \"X:/secure-messenger/node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate.js\";\nimport _asyncIterator from \"X:/secure-messenger/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport { ɵConsole as _Console, InjectionToken, makeEnvironmentProviders, ɵENABLE_ROOT_COMPONENT_BOOTSTRAP as _ENABLE_ROOT_COMPONENT_BOOTSTRAP, ApplicationRef, Compiler, runInInjectionContext, ɵresetCompiledComponents as _resetCompiledComponents, REQUEST, REQUEST_CONTEXT, RESPONSE_INIT, LOCALE_ID } from '@angular/core';\nimport { ROUTES, Router, ɵloadChildren as _loadChildren } from '@angular/router';\nimport { APP_BASE_HREF, PlatformLocation } from '@angular/common';\nimport { renderModule, renderApplication, ɵSERVER_CONTEXT as _SERVER_CONTEXT, platformServer, INITIAL_CONFIG } from '@angular/platform-server';\nimport Beasties from '../third_party/beasties/index.js';\n\n/**\r\n * Manages server-side assets.\r\n */\nclass ServerAssets {\n  manifest;\n  /**\r\n   * Creates an instance of ServerAsset.\r\n   *\r\n   * @param manifest - The manifest containing the server assets.\r\n   */\n  constructor(manifest) {\n    this.manifest = manifest;\n  }\n  /**\r\n   * Retrieves the content of a server-side asset using its path.\r\n   *\r\n   * @param path - The path to the server asset within the manifest.\r\n   * @returns The server asset associated with the provided path, as a `ServerAsset` object.\r\n   * @throws Error - Throws an error if the asset does not exist.\r\n   */\n  getServerAsset(path) {\n    const asset = this.manifest.assets[path];\n    if (!asset) {\n      throw new Error(`Server asset '${path}' does not exist.`);\n    }\n    return asset;\n  }\n  /**\r\n   * Checks if a specific server-side asset exists.\r\n   *\r\n   * @param path - The path to the server asset.\r\n   * @returns A boolean indicating whether the asset exists.\r\n   */\n  hasServerAsset(path) {\n    return !!this.manifest.assets[path];\n  }\n  /**\r\n   * Retrieves the asset for 'index.server.html'.\r\n   *\r\n   * @returns The `ServerAsset` object for 'index.server.html'.\r\n   * @throws Error - Throws an error if 'index.server.html' does not exist.\r\n   */\n  getIndexServerHtml() {\n    return this.getServerAsset('index.server.html');\n  }\n}\n\n/**\r\n * A set of log messages that should be ignored and not printed to the console.\r\n */\nconst IGNORED_LOGS = /*#__PURE__*/new Set(['Angular is running in development mode.']);\n/**\r\n * Custom implementation of the Angular Console service that filters out specific log messages.\r\n *\r\n * This class extends the internal Angular `ɵConsole` class to provide customized logging behavior.\r\n * It overrides the `log` method to suppress logs that match certain predefined messages.\r\n */\nclass Console extends _Console {\n  /**\r\n   * Logs a message to the console if it is not in the set of ignored messages.\r\n   *\r\n   * @param message - The message to log to the console.\r\n   *\r\n   * This method overrides the `log` method of the `ɵConsole` class. It checks if the\r\n   * message is in the `IGNORED_LOGS` set. If it is not, it delegates the logging to\r\n   * the parent class's `log` method. Otherwise, the message is suppressed.\r\n   */\n  log(message) {\n    if (!IGNORED_LOGS.has(message)) {\n      super.log(message);\n    }\n  }\n}\n\n/**\r\n * The Angular app manifest object.\r\n * This is used internally to store the current Angular app manifest.\r\n */\nlet angularAppManifest;\n/**\r\n * Sets the Angular app manifest.\r\n *\r\n * @param manifest - The manifest object to set for the Angular application.\r\n */\nfunction setAngularAppManifest(manifest) {\n  angularAppManifest = manifest;\n}\n/**\r\n * Gets the Angular app manifest.\r\n *\r\n * @returns The Angular app manifest.\r\n * @throws Will throw an error if the Angular app manifest is not set.\r\n */\nfunction getAngularAppManifest() {\n  if (!angularAppManifest) {\n    throw new Error('Angular app manifest is not set. ' + `Please ensure you are using the '@angular/build:application' builder to build your server application.`);\n  }\n  return angularAppManifest;\n}\n/**\r\n * The Angular app engine manifest object.\r\n * This is used internally to store the current Angular app engine manifest.\r\n */\nlet angularAppEngineManifest;\n/**\r\n * Sets the Angular app engine manifest.\r\n *\r\n * @param manifest - The engine manifest object to set.\r\n */\nfunction setAngularAppEngineManifest(manifest) {\n  angularAppEngineManifest = manifest;\n}\n/**\r\n * Gets the Angular app engine manifest.\r\n *\r\n * @returns The Angular app engine manifest.\r\n * @throws Will throw an error if the Angular app engine manifest is not set.\r\n */\nfunction getAngularAppEngineManifest() {\n  if (!angularAppEngineManifest) {\n    throw new Error('Angular app engine manifest is not set. ' + `Please ensure you are using the '@angular/build:application' builder to build your server application.`);\n  }\n  return angularAppEngineManifest;\n}\n\n/**\r\n * Removes the trailing slash from a URL if it exists.\r\n *\r\n * @param url - The URL string from which to remove the trailing slash.\r\n * @returns The URL string without a trailing slash.\r\n *\r\n * @example\r\n * ```js\r\n * stripTrailingSlash('path/'); // 'path'\r\n * stripTrailingSlash('/path');  // '/path'\r\n * stripTrailingSlash('/'); // '/'\r\n * stripTrailingSlash(''); // ''\r\n * ```\r\n */\n/**\r\n * Removes the leading slash from a URL if it exists.\r\n *\r\n * @param url - The URL string from which to remove the leading slash.\r\n * @returns The URL string without a leading slash.\r\n *\r\n * @example\r\n * ```js\r\n * stripLeadingSlash('/path'); // 'path'\r\n * stripLeadingSlash('/path/');  // 'path/'\r\n * stripLeadingSlash('/'); // '/'\r\n * stripLeadingSlash(''); // ''\r\n * ```\r\n */\nfunction stripLeadingSlash(url) {\n  // Check if the first character of the URL is a slash\n  return url.length > 1 && url[0] === '/' ? url.slice(1) : url;\n}\n/**\r\n * Adds a leading slash to a URL if it does not already have one.\r\n *\r\n * @param url - The URL string to which the leading slash will be added.\r\n * @returns The URL string with a leading slash.\r\n *\r\n * @example\r\n * ```js\r\n * addLeadingSlash('path'); // '/path'\r\n * addLeadingSlash('/path'); // '/path'\r\n * ```\r\n */\nfunction addLeadingSlash(url) {\n  // Check if the URL already starts with a slash\n  return url[0] === '/' ? url : `/${url}`;\n}\n/**\r\n * Adds a trailing slash to a URL if it does not already have one.\r\n *\r\n * @param url - The URL string to which the trailing slash will be added.\r\n * @returns The URL string with a trailing slash.\r\n *\r\n * @example\r\n * ```js\r\n * addTrailingSlash('path'); // 'path/'\r\n * addTrailingSlash('path/'); // 'path/'\r\n * ```\r\n */\nfunction addTrailingSlash(url) {\n  // Check if the URL already end with a slash\n  return url[url.length - 1] === '/' ? url : `${url}/`;\n}\n/**\r\n * Joins URL parts into a single URL string.\r\n *\r\n * This function takes multiple URL segments, normalizes them by removing leading\r\n * and trailing slashes where appropriate, and then joins them into a single URL.\r\n *\r\n * @param parts - The parts of the URL to join. Each part can be a string with or without slashes.\r\n * @returns The joined URL string, with normalized slashes.\r\n *\r\n * @example\r\n * ```js\r\n * joinUrlParts('path/', '/to/resource'); // '/path/to/resource'\r\n * joinUrlParts('/path/', 'to/resource'); // '/path/to/resource'\r\n * joinUrlParts('', ''); // '/'\r\n * ```\r\n */\nfunction joinUrlParts(...parts) {\n  const normalizeParts = [];\n  for (const part of parts) {\n    if (part === '') {\n      // Skip any empty parts\n      continue;\n    }\n    let normalizedPart = part;\n    if (part[0] === '/') {\n      normalizedPart = normalizedPart.slice(1);\n    }\n    if (part[part.length - 1] === '/') {\n      normalizedPart = normalizedPart.slice(0, -1);\n    }\n    if (normalizedPart !== '') {\n      normalizeParts.push(normalizedPart);\n    }\n  }\n  return addLeadingSlash(normalizeParts.join('/'));\n}\n/**\r\n * Strips `/index.html` from the end of a URL's path, if present.\r\n *\r\n * This function is used to convert URLs pointing to an `index.html` file into their directory\r\n * equivalents. For example, it transforms a URL like `http://www.example.com/page/index.html`\r\n * into `http://www.example.com/page`.\r\n *\r\n * @param url - The URL object to process.\r\n * @returns A new URL object with `/index.html` removed from the path, if it was present.\r\n *\r\n * @example\r\n * ```typescript\r\n * const originalUrl = new URL('http://www.example.com/page/index.html');\r\n * const cleanedUrl = stripIndexHtmlFromURL(originalUrl);\r\n * console.log(cleanedUrl.href); // Output: 'http://www.example.com/page'\r\n * ```\r\n */\nfunction stripIndexHtmlFromURL(url) {\n  if (url.pathname.endsWith('/index.html')) {\n    const modifiedURL = new URL(url);\n    // Remove '/index.html' from the pathname\n    modifiedURL.pathname = modifiedURL.pathname.slice(0, /** '/index.html'.length */-11);\n    return modifiedURL;\n  }\n  return url;\n}\n/**\r\n * Resolves `*` placeholders in a path template by mapping them to corresponding segments\r\n * from a base path. This is useful for constructing paths dynamically based on a given base path.\r\n *\r\n * The function processes the `toPath` string, replacing each `*` placeholder with\r\n * the corresponding segment from the `fromPath`. If the `toPath` contains no placeholders,\r\n * it is returned as-is. Invalid `toPath` formats (not starting with `/`) will throw an error.\r\n *\r\n * @param toPath - A path template string that may contain `*` placeholders. Each `*` is replaced\r\n * by the corresponding segment from the `fromPath`. Static paths (e.g., `/static/path`) are returned\r\n * directly without placeholder replacement.\r\n * @param fromPath - A base path string, split into segments, that provides values for\r\n * replacing `*` placeholders in the `toPath`.\r\n * @returns A resolved path string with `*` placeholders replaced by segments from the `fromPath`,\r\n * or the `toPath` returned unchanged if it contains no placeholders.\r\n *\r\n * @throws If the `toPath` does not start with a `/`, indicating an invalid path format.\r\n *\r\n * @example\r\n * ```typescript\r\n * // Example with placeholders resolved\r\n * const resolvedPath = buildPathWithParams('/*\\/details', '/123/abc');\r\n * console.log(resolvedPath); // Outputs: '/123/details'\r\n *\r\n * // Example with a static path\r\n * const staticPath = buildPathWithParams('/static/path', '/base/unused');\r\n * console.log(staticPath); // Outputs: '/static/path'\r\n * ```\r\n */\nfunction buildPathWithParams(toPath, fromPath) {\n  if (toPath[0] !== '/') {\n    throw new Error(`Invalid toPath: The string must start with a '/'. Received: '${toPath}'`);\n  }\n  if (fromPath[0] !== '/') {\n    throw new Error(`Invalid fromPath: The string must start with a '/'. Received: '${fromPath}'`);\n  }\n  if (!toPath.includes('/*')) {\n    return toPath;\n  }\n  const fromPathParts = fromPath.split('/');\n  const toPathParts = toPath.split('/');\n  const resolvedParts = toPathParts.map((part, index) => toPathParts[index] === '*' ? fromPathParts[index] : part);\n  return joinUrlParts(...resolvedParts);\n}\n\n/**\r\n * Renders an Angular application or module to an HTML string.\r\n *\r\n * This function determines whether the provided `bootstrap` value is an Angular module\r\n * or a bootstrap function and calls the appropriate rendering method (`renderModule` or\r\n * `renderApplication`) based on that determination.\r\n *\r\n * @param html - The HTML string to be used as the initial document content.\r\n * @param bootstrap - Either an Angular module type or a function that returns a promise\r\n *                    resolving to an `ApplicationRef`.\r\n * @param url - The URL of the application. This is used for server-side rendering to\r\n *              correctly handle route-based rendering.\r\n * @param platformProviders - An array of platform providers to be used during the\r\n *                             rendering process.\r\n * @param serverContext - A string representing the server context, used to provide additional\r\n *                        context or metadata during server-side rendering.\r\n * @returns A promise that resolves to a string containing the rendered HTML.\r\n */\nfunction renderAngular(html, bootstrap, url, platformProviders, serverContext) {\n  const providers = [{\n    provide: _SERVER_CONTEXT,\n    useValue: serverContext\n  }, {\n    // An Angular Console Provider that does not print a set of predefined logs.\n    provide: _Console,\n    // Using `useClass` would necessitate decorating `Console` with `@Injectable`,\n    // which would require switching from `ts_library` to `ng_module`. This change\n    // would also necessitate various patches of `@angular/bazel` to support ESM.\n    useFactory: () => new Console()\n  }, ...platformProviders];\n  // A request to `http://www.example.com/page/index.html` will render the Angular route corresponding to `http://www.example.com/page`.\n  const urlToRender = stripIndexHtmlFromURL(url).toString();\n  return isNgModule(bootstrap) ? renderModule(bootstrap, {\n    url: urlToRender,\n    document: html,\n    extraProviders: providers\n  }) : renderApplication(bootstrap, {\n    url: urlToRender,\n    document: html,\n    platformProviders: providers\n  });\n}\n/**\r\n * Type guard to determine if a given value is an Angular module.\r\n * Angular modules are identified by the presence of the `ɵmod` static property.\r\n * This function helps distinguish between Angular modules and bootstrap functions.\r\n *\r\n * @param value - The value to be checked.\r\n * @returns True if the value is an Angular module (i.e., it has the `ɵmod` property), false otherwise.\r\n */\nfunction isNgModule(value) {\n  return 'ɵmod' in value;\n}\n\n/**\r\n * Creates a promise that resolves with the result of the provided `promise` or rejects with an\r\n * `AbortError` if the `AbortSignal` is triggered before the promise resolves.\r\n *\r\n * @param promise - The promise to monitor for completion.\r\n * @param signal - An `AbortSignal` used to monitor for an abort event. If the signal is aborted,\r\n *                 the returned promise will reject.\r\n * @param errorMessagePrefix - A custom message prefix to include in the error message when the operation is aborted.\r\n * @returns A promise that either resolves with the value of the provided `promise` or rejects with\r\n *          an `AbortError` if the `AbortSignal` is triggered.\r\n *\r\n * @throws {AbortError} If the `AbortSignal` is triggered before the `promise` resolves.\r\n */\nfunction promiseWithAbort(promise, signal, errorMessagePrefix) {\n  return new Promise((resolve, reject) => {\n    const abortHandler = () => {\n      reject(new DOMException(`${errorMessagePrefix} was aborted.\\n${signal.reason}`, 'AbortError'));\n    };\n    // Check for abort signal\n    if (signal.aborted) {\n      abortHandler();\n      return;\n    }\n    signal.addEventListener('abort', abortHandler, {\n      once: true\n    });\n    promise.then(resolve).catch(reject).finally(() => {\n      signal.removeEventListener('abort', abortHandler);\n    });\n  });\n}\n\n/**\r\n * The internal path used for the app shell route.\r\n * @internal\r\n */\nconst APP_SHELL_ROUTE = 'ng-app-shell';\n/**\r\n * Identifies a particular kind of `ServerRoutesFeatureKind`.\r\n * @see {@link ServerRoutesFeature}\r\n * @developerPreview\r\n */\nvar ServerRoutesFeatureKind = /*#__PURE__*/function (ServerRoutesFeatureKind) {\n  ServerRoutesFeatureKind[ServerRoutesFeatureKind[\"AppShell\"] = 0] = \"AppShell\";\n  return ServerRoutesFeatureKind;\n}(ServerRoutesFeatureKind || {});\n/**\r\n * Different rendering modes for server routes.\r\n * @see {@link provideServerRouting}\r\n * @see {@link ServerRoute}\r\n * @developerPreview\r\n */\nvar RenderMode = /*#__PURE__*/function (RenderMode) {\n  /** Server-Side Rendering (SSR) mode, where content is rendered on the server for each request. */\n  RenderMode[RenderMode[\"Server\"] = 0] = \"Server\";\n  /** Client-Side Rendering (CSR) mode, where content is rendered on the client side in the browser. */\n  RenderMode[RenderMode[\"Client\"] = 1] = \"Client\";\n  /** Static Site Generation (SSG) mode, where content is pre-rendered at build time and served as static files. */\n  RenderMode[RenderMode[\"Prerender\"] = 2] = \"Prerender\";\n  return RenderMode;\n}(RenderMode || {});\n/**\r\n * Defines the fallback strategies for Static Site Generation (SSG) routes when a pre-rendered path is not available.\r\n * This is particularly relevant for routes with parameterized URLs where some paths might not be pre-rendered at build time.\r\n * @see {@link ServerRoutePrerenderWithParams}\r\n * @developerPreview\r\n */\nvar PrerenderFallback = /*#__PURE__*/function (PrerenderFallback) {\n  /**\r\n   * Fallback to Server-Side Rendering (SSR) if the pre-rendered path is not available.\r\n   * This strategy dynamically generates the page on the server at request time.\r\n   */\n  PrerenderFallback[PrerenderFallback[\"Server\"] = 0] = \"Server\";\n  /**\r\n   * Fallback to Client-Side Rendering (CSR) if the pre-rendered path is not available.\r\n   * This strategy allows the page to be rendered on the client side.\r\n   */\n  PrerenderFallback[PrerenderFallback[\"Client\"] = 1] = \"Client\";\n  /**\r\n   * No fallback; if the path is not pre-rendered, the server will not handle the request.\r\n   * This means the application will not provide any response for paths that are not pre-rendered.\r\n   */\n  PrerenderFallback[PrerenderFallback[\"None\"] = 2] = \"None\";\n  return PrerenderFallback;\n}(PrerenderFallback || {});\n/**\r\n * Token for providing the server routes configuration.\r\n * @internal\r\n */\nconst SERVER_ROUTES_CONFIG = /*#__PURE__*/new InjectionToken('SERVER_ROUTES_CONFIG');\n/**\r\n * Sets up the necessary providers for configuring server routes.\r\n * This function accepts an array of server routes and optional configuration\r\n * options, returning an `EnvironmentProviders` object that encapsulates\r\n * the server routes and configuration settings.\r\n *\r\n * @param routes - An array of server routes to be provided.\r\n * @param options - (Optional) An object containing additional configuration options for server routes.\r\n * @returns An `EnvironmentProviders` instance with the server routes configuration.\r\n *\r\n * @see {@link ServerRoute}\r\n * @see {@link ServerRoutesConfigOptions}\r\n * @see {@link provideServerRouting}\r\n * @deprecated use `provideServerRouting`. This will be removed in version 20.\r\n * @developerPreview\r\n */\nfunction provideServerRoutesConfig(routes, options) {\n  if (typeof ngServerMode === 'undefined' || !ngServerMode) {\n    throw new Error(`The 'provideServerRoutesConfig' function should not be invoked within the browser portion of the application.`);\n  }\n  return makeEnvironmentProviders([{\n    provide: SERVER_ROUTES_CONFIG,\n    useValue: {\n      routes,\n      ...options\n    }\n  }]);\n}\n/**\r\n * Sets up the necessary providers for configuring server routes.\r\n * This function accepts an array of server routes and optional configuration\r\n * options, returning an `EnvironmentProviders` object that encapsulates\r\n * the server routes and configuration settings.\r\n *\r\n * @param routes - An array of server routes to be provided.\r\n * @param features - (Optional) server routes features.\r\n * @returns An `EnvironmentProviders` instance with the server routes configuration.\r\n *\r\n * @see {@link ServerRoute}\r\n * @see {@link withAppShell}\r\n * @developerPreview\r\n */\nfunction provideServerRouting(routes, ...features) {\n  const config = {\n    routes\n  };\n  const hasAppShell = features.some(f => f.ɵkind === ServerRoutesFeatureKind.AppShell);\n  if (hasAppShell) {\n    config.appShellRoute = APP_SHELL_ROUTE;\n  }\n  const providers = [{\n    provide: SERVER_ROUTES_CONFIG,\n    useValue: config\n  }];\n  for (const feature of features) {\n    providers.push(...feature.ɵproviders);\n  }\n  return makeEnvironmentProviders(providers);\n}\n/**\r\n * Configures the app shell route with the provided component.\r\n *\r\n * The app shell serves as the main entry point for the application and is commonly used\r\n * to enable server-side rendering (SSR) of the application shell. It handles requests\r\n * that do not match any specific server route, providing a fallback mechanism and improving\r\n * perceived performance during navigation.\r\n *\r\n * This configuration is particularly useful in applications leveraging Progressive Web App (PWA)\r\n * patterns, such as service workers, to deliver a seamless user experience.\r\n *\r\n * @param component The Angular component to render for the app shell route.\r\n * @returns A server routes feature configuration for the app shell.\r\n *\r\n * @see {@link provideServerRouting}\r\n * @see {@link https://angular.dev/ecosystem/service-workers/app-shell | App shell pattern on Angular.dev}\r\n */\nfunction withAppShell(component) {\n  const routeConfig = {\n    path: APP_SHELL_ROUTE\n  };\n  if ('ɵcmp' in component) {\n    routeConfig.component = component;\n  } else {\n    routeConfig.loadComponent = component;\n  }\n  return {\n    ɵkind: ServerRoutesFeatureKind.AppShell,\n    ɵproviders: [{\n      provide: ROUTES,\n      useValue: routeConfig,\n      multi: true\n    }]\n  };\n}\n\n/**\r\n * A route tree implementation that supports efficient route matching, including support for wildcard routes.\r\n * This structure is useful for organizing and retrieving routes in a hierarchical manner,\r\n * enabling complex routing scenarios with nested paths.\r\n *\r\n * @typeParam AdditionalMetadata - Type of additional metadata that can be associated with route nodes.\r\n */\nclass RouteTree {\n  /**\r\n   * The root node of the route tree.\r\n   * All routes are stored and accessed relative to this root node.\r\n   */\n  root = /*#__PURE__*/this.createEmptyRouteTreeNode();\n  /**\r\n   * Inserts a new route into the route tree.\r\n   * The route is broken down into segments, and each segment is added to the tree.\r\n   * Parameterized segments (e.g., :id) are normalized to wildcards (*) for matching purposes.\r\n   *\r\n   * @param route - The route path to insert into the tree.\r\n   * @param metadata - Metadata associated with the route, excluding the route path itself.\r\n   */\n  insert(route, metadata) {\n    let node = this.root;\n    const segments = this.getPathSegments(route);\n    const normalizedSegments = [];\n    for (const segment of segments) {\n      // Replace parameterized segments (e.g., :id) with a wildcard (*) for matching\n      const normalizedSegment = segment[0] === ':' ? '*' : segment;\n      let childNode = node.children.get(normalizedSegment);\n      if (!childNode) {\n        childNode = this.createEmptyRouteTreeNode();\n        node.children.set(normalizedSegment, childNode);\n      }\n      node = childNode;\n      normalizedSegments.push(normalizedSegment);\n    }\n    // At the leaf node, store the full route and its associated metadata\n    node.metadata = {\n      ...metadata,\n      route: addLeadingSlash(normalizedSegments.join('/'))\n    };\n  }\n  /**\r\n   * Matches a given route against the route tree and returns the best matching route's metadata.\r\n   * The best match is determined by the lowest insertion index, meaning the earliest defined route\r\n   * takes precedence.\r\n   *\r\n   * @param route - The route path to match against the route tree.\r\n   * @returns The metadata of the best matching route or `undefined` if no match is found.\r\n   */\n  match(route) {\n    const segments = this.getPathSegments(route);\n    return this.traverseBySegments(segments)?.metadata;\n  }\n  /**\r\n   * Converts the route tree into a serialized format representation.\r\n   * This method converts the route tree into an array of metadata objects that describe the structure of the tree.\r\n   * The array represents the routes in a nested manner where each entry includes the route and its associated metadata.\r\n   *\r\n   * @returns An array of `RouteTreeNodeMetadata` objects representing the route tree structure.\r\n   *          Each object includes the `route` and associated metadata of a route.\r\n   */\n  toObject() {\n    return Array.from(this.traverse());\n  }\n  /**\r\n   * Constructs a `RouteTree` from an object representation.\r\n   * This method is used to recreate a `RouteTree` instance from an array of metadata objects.\r\n   * The array should be in the format produced by `toObject`, allowing for the reconstruction of the route tree\r\n   * with the same routes and metadata.\r\n   *\r\n   * @param value - An array of `RouteTreeNodeMetadata` objects that represent the serialized format of the route tree.\r\n   *                Each object should include a `route` and its associated metadata.\r\n   * @returns A new `RouteTree` instance constructed from the provided metadata objects.\r\n   */\n  static fromObject(value) {\n    const tree = new RouteTree();\n    for (const {\n      route,\n      ...metadata\n    } of value) {\n      tree.insert(route, metadata);\n    }\n    return tree;\n  }\n  /**\r\n   * A generator function that recursively traverses the route tree and yields the metadata of each node.\r\n   * This allows for easy and efficient iteration over all nodes in the tree.\r\n   *\r\n   * @param node - The current node to start the traversal from. Defaults to the root node of the tree.\r\n   */\n  *traverse(node = this.root) {\n    if (node.metadata) {\n      yield node.metadata;\n    }\n    for (const childNode of node.children.values()) {\n      yield* this.traverse(childNode);\n    }\n  }\n  /**\r\n   * Extracts the path segments from a given route string.\r\n   *\r\n   * @param route - The route string from which to extract segments.\r\n   * @returns An array of path segments.\r\n   */\n  getPathSegments(route) {\n    return route.split('/').filter(Boolean);\n  }\n  /**\r\n   * Recursively traverses the route tree from a given node, attempting to match the remaining route segments.\r\n   * If the node is a leaf node (no more segments to match) and contains metadata, the node is yielded.\r\n   *\r\n   * This function prioritizes exact segment matches first, followed by wildcard matches (`*`),\r\n   * and finally deep wildcard matches (`**`) that consume all segments.\r\n   *\r\n   * @param segments - The array of route path segments to match against the route tree.\r\n   * @param node - The current node in the route tree to start traversal from. Defaults to the root node.\r\n   * @param currentIndex - The index of the segment in `remainingSegments` currently being matched.\r\n   * Defaults to `0` (the first segment).\r\n   *\r\n   * @returns The node that best matches the remaining segments or `undefined` if no match is found.\r\n   */\n  traverseBySegments(segments, node = this.root, currentIndex = 0) {\n    if (currentIndex >= segments.length) {\n      return node.metadata ? node : node.children.get('**');\n    }\n    if (!node.children.size) {\n      return undefined;\n    }\n    const segment = segments[currentIndex];\n    // 1. Attempt exact match with the current segment.\n    const exactMatch = node.children.get(segment);\n    if (exactMatch) {\n      const match = this.traverseBySegments(segments, exactMatch, currentIndex + 1);\n      if (match) {\n        return match;\n      }\n    }\n    // 2. Attempt wildcard match ('*').\n    const wildcardMatch = node.children.get('*');\n    if (wildcardMatch) {\n      const match = this.traverseBySegments(segments, wildcardMatch, currentIndex + 1);\n      if (match) {\n        return match;\n      }\n    }\n    // 3. Attempt double wildcard match ('**').\n    return node.children.get('**');\n  }\n  /**\r\n   * Creates an empty route tree node.\r\n   * This helper function is used during the tree construction.\r\n   *\r\n   * @returns A new, empty route tree node.\r\n   */\n  createEmptyRouteTreeNode() {\n    return {\n      children: new Map()\n    };\n  }\n}\n\n/**\r\n * The maximum number of module preload link elements that should be added for\r\n * initial scripts.\r\n */\nconst MODULE_PRELOAD_MAX = 10;\n/**\r\n * Regular expression to match a catch-all route pattern in a URL path,\r\n * specifically one that ends with '/**'.\r\n */\nconst CATCH_ALL_REGEXP = /\\/(\\*\\*)$/;\n/**\r\n * Regular expression to match segments preceded by a colon in a string.\r\n */\nconst URL_PARAMETER_REGEXP = /(?<!\\\\):([^/]+)/g;\n/**\r\n * An set of HTTP status codes that are considered valid for redirect responses.\r\n */\nconst VALID_REDIRECT_RESPONSE_CODES = /*#__PURE__*/new Set([301, 302, 303, 307, 308]);\n/**\r\n * Handles a single route within the route tree and yields metadata or errors.\r\n *\r\n * @param options - Configuration options for handling the route.\r\n * @returns An async iterable iterator yielding `RouteTreeNodeMetadata` or an error object.\r\n */\nfunction handleRoute(_x) {\n  return _handleRoute.apply(this, arguments);\n}\n/**\r\n * Traverses an array of route configurations to generate route tree node metadata.\r\n *\r\n * This function processes each route and its children, handling redirects, SSG (Static Site Generation) settings,\r\n * and lazy-loaded routes. It yields route metadata for each route and its potential variants.\r\n *\r\n * @param options - The configuration options for traversing routes.\r\n * @returns An async iterable iterator yielding either route tree node metadata or an error object with an error message.\r\n */\nfunction _handleRoute() {\n  _handleRoute = _wrapAsyncGenerator(function* (options) {\n    try {\n      const {\n        metadata,\n        currentRoutePath,\n        route,\n        compiler,\n        parentInjector,\n        serverConfigRouteTree,\n        entryPointToBrowserMapping,\n        invokeGetPrerenderParams,\n        includePrerenderFallbackRoutes\n      } = options;\n      const {\n        redirectTo,\n        loadChildren,\n        loadComponent,\n        children,\n        ɵentryName\n      } = route;\n      if (ɵentryName && loadComponent) {\n        appendPreloadToMetadata(ɵentryName, entryPointToBrowserMapping, metadata, true);\n      }\n      if (metadata.renderMode === RenderMode.Prerender) {\n        yield* _asyncGeneratorDelegate(_asyncIterator(handleSSGRoute(serverConfigRouteTree, typeof redirectTo === 'string' ? redirectTo : undefined, metadata, parentInjector, invokeGetPrerenderParams, includePrerenderFallbackRoutes)), _awaitAsyncGenerator);\n      } else if (typeof redirectTo === 'string') {\n        if (metadata.status && !VALID_REDIRECT_RESPONSE_CODES.has(metadata.status)) {\n          yield {\n            error: `The '${metadata.status}' status code is not a valid redirect response code. ` + `Please use one of the following redirect response codes: ${[...VALID_REDIRECT_RESPONSE_CODES.values()].join(', ')}.`\n          };\n        } else {\n          yield {\n            ...metadata,\n            redirectTo: resolveRedirectTo(metadata.route, redirectTo)\n          };\n        }\n      } else {\n        yield metadata;\n      }\n      // Recursively process child routes\n      if (children?.length) {\n        yield* _asyncGeneratorDelegate(_asyncIterator(traverseRoutesConfig({\n          ...options,\n          routes: children,\n          parentRoute: currentRoutePath,\n          parentPreloads: metadata.preload\n        })), _awaitAsyncGenerator);\n      }\n      // Load and process lazy-loaded child routes\n      if (loadChildren) {\n        if (ɵentryName) {\n          // When using `loadChildren`, the entire feature area (including multiple routes) is loaded.\n          // As a result, we do not want all dynamic-import dependencies to be preload, because it involves multiple dependencies\n          // across different child routes. In contrast, `loadComponent` only loads a single component, which allows\n          // for precise control over preloading, ensuring that the files preloaded are exactly those required for that specific route.\n          appendPreloadToMetadata(ɵentryName, entryPointToBrowserMapping, metadata, false);\n        }\n        const loadedChildRoutes = yield _awaitAsyncGenerator(_loadChildren(route, compiler, parentInjector).toPromise());\n        if (loadedChildRoutes) {\n          const {\n            routes: childRoutes,\n            injector = parentInjector\n          } = loadedChildRoutes;\n          yield* _asyncGeneratorDelegate(_asyncIterator(traverseRoutesConfig({\n            ...options,\n            routes: childRoutes,\n            parentInjector: injector,\n            parentRoute: currentRoutePath,\n            parentPreloads: metadata.preload\n          })), _awaitAsyncGenerator);\n        }\n      }\n    } catch (error) {\n      yield {\n        error: `Error in handleRoute for '${options.currentRoutePath}': ${error.message}`\n      };\n    }\n  });\n  return _handleRoute.apply(this, arguments);\n}\nfunction traverseRoutesConfig(_x2) {\n  return _traverseRoutesConfig.apply(this, arguments);\n}\n/**\r\n * Appends preload information to the metadata object based on the specified entry-point and chunk mappings.\r\n *\r\n * This function extracts preload data for a given entry-point from the provided chunk mappings. It adds the\r\n * corresponding browser bundles to the metadata's preload list, ensuring no duplicates and limiting the total\r\n * preloads to a predefined maximum.\r\n */\nfunction _traverseRoutesConfig() {\n  _traverseRoutesConfig = _wrapAsyncGenerator(function* (options) {\n    const {\n      routes: routeConfigs,\n      parentPreloads,\n      parentRoute,\n      serverConfigRouteTree\n    } = options;\n    for (const route of routeConfigs) {\n      const {\n        matcher,\n        path = matcher ? '**' : ''\n      } = route;\n      const currentRoutePath = joinUrlParts(parentRoute, path);\n      if (matcher && serverConfigRouteTree) {\n        let foundMatch = false;\n        for (const matchedMetaData of serverConfigRouteTree.traverse()) {\n          if (!matchedMetaData.route.startsWith(currentRoutePath)) {\n            continue;\n          }\n          foundMatch = true;\n          matchedMetaData.presentInClientRouter = true;\n          if (matchedMetaData.renderMode === RenderMode.Prerender) {\n            yield {\n              error: `The route '${stripLeadingSlash(currentRoutePath)}' is set for prerendering but has a defined matcher. ` + `Routes with matchers cannot use prerendering. Please specify a different 'renderMode'.`\n            };\n            continue;\n          }\n          yield* _asyncGeneratorDelegate(_asyncIterator(handleRoute({\n            ...options,\n            currentRoutePath,\n            route,\n            metadata: {\n              ...matchedMetaData,\n              preload: parentPreloads,\n              route: matchedMetaData.route,\n              presentInClientRouter: undefined\n            }\n          })), _awaitAsyncGenerator);\n        }\n        if (!foundMatch) {\n          yield {\n            error: `The route '${stripLeadingSlash(currentRoutePath)}' has a defined matcher but does not ` + 'match any route in the server routing configuration. Please ensure this route is added to the server routing configuration.'\n          };\n        }\n        continue;\n      }\n      let matchedMetaData;\n      if (serverConfigRouteTree) {\n        matchedMetaData = serverConfigRouteTree.match(currentRoutePath);\n        if (!matchedMetaData) {\n          yield {\n            error: `The '${stripLeadingSlash(currentRoutePath)}' route does not match any route defined in the server routing configuration. ` + 'Please ensure this route is added to the server routing configuration.'\n          };\n          continue;\n        }\n        matchedMetaData.presentInClientRouter = true;\n      }\n      yield* _asyncGeneratorDelegate(_asyncIterator(handleRoute({\n        ...options,\n        metadata: {\n          renderMode: RenderMode.Prerender,\n          ...matchedMetaData,\n          preload: parentPreloads,\n          // Match Angular router behavior\n          // ['one', 'two', ''] -> 'one/two/'\n          // ['one', 'two', 'three'] -> 'one/two/three'\n          route: path === '' ? addTrailingSlash(currentRoutePath) : currentRoutePath,\n          presentInClientRouter: undefined\n        },\n        currentRoutePath,\n        route\n      })), _awaitAsyncGenerator);\n    }\n  });\n  return _traverseRoutesConfig.apply(this, arguments);\n}\nfunction appendPreloadToMetadata(entryName, entryPointToBrowserMapping, metadata, includeDynamicImports) {\n  const existingPreloads = metadata.preload ?? [];\n  if (!entryPointToBrowserMapping || existingPreloads.length >= MODULE_PRELOAD_MAX) {\n    return;\n  }\n  const preload = entryPointToBrowserMapping[entryName];\n  if (!preload?.length) {\n    return;\n  }\n  // Merge existing preloads with new ones, ensuring uniqueness and limiting the total to the maximum allowed.\n  const combinedPreloads = new Set(existingPreloads);\n  for (const {\n    dynamicImport,\n    path\n  } of preload) {\n    if (dynamicImport && !includeDynamicImports) {\n      continue;\n    }\n    combinedPreloads.add(path);\n    if (combinedPreloads.size === MODULE_PRELOAD_MAX) {\n      break;\n    }\n  }\n  metadata.preload = Array.from(combinedPreloads);\n}\n/**\r\n * Handles SSG (Static Site Generation) routes by invoking `getPrerenderParams` and yielding\r\n * all parameterized paths, returning any errors encountered.\r\n *\r\n * @param serverConfigRouteTree - The tree representing the server's routing setup.\r\n * @param redirectTo - Optional path to redirect to, if specified.\r\n * @param metadata - The metadata associated with the route tree node.\r\n * @param parentInjector - The dependency injection container for the parent route.\r\n * @param invokeGetPrerenderParams - A flag indicating whether to invoke the `getPrerenderParams` function.\r\n * @param includePrerenderFallbackRoutes - A flag indicating whether to include fallback routes in the result.\r\n * @returns An async iterable iterator that yields route tree node metadata for each SSG path or errors.\r\n */\nfunction handleSSGRoute(_x3, _x4, _x5, _x6, _x7, _x8) {\n  return _handleSSGRoute.apply(this, arguments);\n}\n/**\r\n * Creates a replacer function used for substituting parameter placeholders in a route path\r\n * with their corresponding values provided in the `params` object.\r\n *\r\n * @param params - An object mapping parameter names to their string values.\r\n * @param currentRoutePath - The current route path, used for constructing error messages.\r\n * @returns A function that replaces a matched parameter placeholder (e.g., ':id') with its corresponding value.\r\n */\nfunction _handleSSGRoute() {\n  _handleSSGRoute = _wrapAsyncGenerator(function* (serverConfigRouteTree, redirectTo, metadata, parentInjector, invokeGetPrerenderParams, includePrerenderFallbackRoutes) {\n    if (metadata.renderMode !== RenderMode.Prerender) {\n      throw new Error(`'handleSSGRoute' was called for a route which rendering mode is not prerender.`);\n    }\n    const {\n      route: currentRoutePath,\n      fallback,\n      ...meta\n    } = metadata;\n    const getPrerenderParams = 'getPrerenderParams' in meta ? meta.getPrerenderParams : undefined;\n    if ('getPrerenderParams' in meta) {\n      delete meta['getPrerenderParams'];\n    }\n    if (redirectTo !== undefined) {\n      meta.redirectTo = resolveRedirectTo(currentRoutePath, redirectTo);\n    }\n    const isCatchAllRoute = CATCH_ALL_REGEXP.test(currentRoutePath);\n    if (isCatchAllRoute && !getPrerenderParams || !isCatchAllRoute && !URL_PARAMETER_REGEXP.test(currentRoutePath)) {\n      // Route has no parameters\n      yield {\n        ...meta,\n        route: currentRoutePath\n      };\n      return;\n    }\n    if (invokeGetPrerenderParams) {\n      if (!getPrerenderParams) {\n        yield {\n          error: `The '${stripLeadingSlash(currentRoutePath)}' route uses prerendering and includes parameters, but 'getPrerenderParams' ` + `is missing. Please define 'getPrerenderParams' function for this route in your server routing configuration ` + `or specify a different 'renderMode'.`\n        };\n        return;\n      }\n      if (serverConfigRouteTree) {\n        // Automatically resolve dynamic parameters for nested routes.\n        const catchAllRoutePath = isCatchAllRoute ? currentRoutePath : joinUrlParts(currentRoutePath, '**');\n        const match = serverConfigRouteTree.match(catchAllRoutePath);\n        if (match && match.renderMode === RenderMode.Prerender && !('getPrerenderParams' in match)) {\n          serverConfigRouteTree.insert(catchAllRoutePath, {\n            ...match,\n            presentInClientRouter: true,\n            getPrerenderParams\n          });\n        }\n      }\n      const parameters = yield _awaitAsyncGenerator(runInInjectionContext(parentInjector, () => getPrerenderParams()));\n      try {\n        for (const params of parameters) {\n          const replacer = handlePrerenderParamsReplacement(params, currentRoutePath);\n          const routeWithResolvedParams = currentRoutePath.replace(URL_PARAMETER_REGEXP, replacer).replace(CATCH_ALL_REGEXP, replacer);\n          yield {\n            ...meta,\n            route: routeWithResolvedParams,\n            redirectTo: redirectTo === undefined ? undefined : resolveRedirectTo(routeWithResolvedParams, redirectTo)\n          };\n        }\n      } catch (error) {\n        yield {\n          error: `${error.message}`\n        };\n        return;\n      }\n    }\n    // Handle fallback render modes\n    if (includePrerenderFallbackRoutes && (fallback !== PrerenderFallback.None || !invokeGetPrerenderParams)) {\n      yield {\n        ...meta,\n        route: currentRoutePath,\n        renderMode: fallback === PrerenderFallback.Client ? RenderMode.Client : RenderMode.Server\n      };\n    }\n  });\n  return _handleSSGRoute.apply(this, arguments);\n}\nfunction handlePrerenderParamsReplacement(params, currentRoutePath) {\n  return match => {\n    const parameterName = match.slice(1);\n    const value = params[parameterName];\n    if (typeof value !== 'string') {\n      throw new Error(`The 'getPrerenderParams' function defined for the '${stripLeadingSlash(currentRoutePath)}' route ` + `returned a non-string value for parameter '${parameterName}'. ` + `Please make sure the 'getPrerenderParams' function returns values for all parameters ` + 'specified in this route.');\n    }\n    return parameterName === '**' ? `/${value}` : value;\n  };\n}\n/**\r\n * Resolves the `redirectTo` property for a given route.\r\n *\r\n * This function processes the `redirectTo` property to ensure that it correctly\r\n * resolves relative to the current route path. If `redirectTo` is an absolute path,\r\n * it is returned as is. If it is a relative path, it is resolved based on the current route path.\r\n *\r\n * @param routePath - The current route path.\r\n * @param redirectTo - The target path for redirection.\r\n * @returns The resolved redirect path as a string.\r\n */\nfunction resolveRedirectTo(routePath, redirectTo) {\n  if (redirectTo[0] === '/') {\n    // If the redirectTo path is absolute, return it as is.\n    return redirectTo;\n  }\n  // Resolve relative redirectTo based on the current route path.\n  const segments = routePath.replace(URL_PARAMETER_REGEXP, '*').split('/');\n  segments.pop(); // Remove the last segment to make it relative.\n  return joinUrlParts(...segments, redirectTo);\n}\n/**\r\n * Builds a server configuration route tree from the given server routes configuration.\r\n *\r\n * @param serverRoutesConfig - The server routes to be used for configuration.\r\n\r\n * @returns An object containing:\r\n * - `serverConfigRouteTree`: A populated `RouteTree` instance, which organizes the server routes\r\n *   along with their additional metadata.\r\n * - `errors`: An array of strings that list any errors encountered during the route tree construction\r\n *   process, such as invalid paths.\r\n */\nfunction buildServerConfigRouteTree({\n  routes,\n  appShellRoute\n}) {\n  const serverRoutes = [...routes];\n  if (appShellRoute !== undefined) {\n    serverRoutes.unshift({\n      path: appShellRoute,\n      renderMode: RenderMode.Prerender\n    });\n  }\n  const serverConfigRouteTree = new RouteTree();\n  const errors = [];\n  for (const {\n    path,\n    ...metadata\n  } of serverRoutes) {\n    if (path[0] === '/') {\n      errors.push(`Invalid '${path}' route configuration: the path cannot start with a slash.`);\n      continue;\n    }\n    if ('getPrerenderParams' in metadata && (path.includes('/*/') || path.endsWith('/*'))) {\n      errors.push(`Invalid '${path}' route configuration: 'getPrerenderParams' cannot be used with a '*' route.`);\n      continue;\n    }\n    serverConfigRouteTree.insert(path, metadata);\n  }\n  return {\n    serverConfigRouteTree,\n    errors\n  };\n}\n/**\r\n * Retrieves routes from the given Angular application.\r\n *\r\n * This function initializes an Angular platform, bootstraps the application or module,\r\n * and retrieves routes from the Angular router configuration. It handles both module-based\r\n * and function-based bootstrapping. It yields the resulting routes as `RouteTreeNodeMetadata` objects or errors.\r\n *\r\n * @param bootstrap - A function that returns a promise resolving to an `ApplicationRef` or an Angular module to bootstrap.\r\n * @param document - The initial HTML document used for server-side rendering.\r\n * This document is necessary to render the application on the server.\r\n * @param url - The URL for server-side rendering. The URL is used to configure `ServerPlatformLocation`. This configuration is crucial\r\n * for ensuring that API requests for relative paths succeed, which is essential for accurate route extraction.\r\n * @param invokeGetPrerenderParams - A boolean flag indicating whether to invoke `getPrerenderParams` for parameterized SSG routes\r\n * to handle prerendering paths. Defaults to `false`.\r\n * @param includePrerenderFallbackRoutes - A flag indicating whether to include fallback routes in the result. Defaults to `true`.\r\n * @param entryPointToBrowserMapping - Maps the entry-point name to the associated JavaScript browser bundles.\r\n *\r\n * @returns A promise that resolves to an object of type `AngularRouterConfigResult` or errors.\r\n */\nfunction getRoutesFromAngularRouterConfig(_x9, _x0, _x1) {\n  return _getRoutesFromAngularRouterConfig.apply(this, arguments);\n}\n/**\r\n * Asynchronously extracts routes from the Angular application configuration\r\n * and creates a `RouteTree` to manage server-side routing.\r\n *\r\n * @param options - An object containing the following options:\r\n *  - `url`: The URL for server-side rendering. The URL is used to configure `ServerPlatformLocation`. This configuration is crucial\r\n *     for ensuring that API requests for relative paths succeed, which is essential for accurate route extraction.\r\n *     See:\r\n *      - https://github.com/angular/angular/blob/d608b857c689d17a7ffa33bbb510301014d24a17/packages/platform-server/src/location.ts#L51\r\n *      - https://github.com/angular/angular/blob/6882cc7d9eed26d3caeedca027452367ba25f2b9/packages/platform-server/src/http.ts#L44\r\n *  - `manifest`: An optional `AngularAppManifest` that contains the application's routing and configuration details.\r\n *     If not provided, the default manifest is retrieved using `getAngularAppManifest()`.\r\n *  - `invokeGetPrerenderParams`: A boolean flag indicating whether to invoke `getPrerenderParams` for parameterized SSG routes\r\n *     to handle prerendering paths. Defaults to `false`.\r\n *  - `includePrerenderFallbackRoutes`: A flag indicating whether to include fallback routes in the result. Defaults to `true`.\r\n *  - `signal`: An optional `AbortSignal` that can be used to abort the operation.\r\n *\r\n * @returns A promise that resolves to an object containing:\r\n *  - `routeTree`: A populated `RouteTree` containing all extracted routes from the Angular application.\r\n *  - `appShellRoute`: The specified route for the app-shell, if configured.\r\n *  - `errors`: An array of strings representing any errors encountered during the route extraction process.\r\n */\nfunction _getRoutesFromAngularRouterConfig() {\n  _getRoutesFromAngularRouterConfig = _asyncToGenerator(function* (bootstrap, document, url, invokeGetPrerenderParams = false, includePrerenderFallbackRoutes = true, entryPointToBrowserMapping = undefined) {\n    const {\n      protocol,\n      host\n    } = url;\n    // Create and initialize the Angular platform for server-side rendering.\n    const platformRef = platformServer([{\n      provide: INITIAL_CONFIG,\n      useValue: {\n        document,\n        url: `${protocol}//${host}/`\n      }\n    }, {\n      // An Angular Console Provider that does not print a set of predefined logs.\n      provide: _Console,\n      // Using `useClass` would necessitate decorating `Console` with `@Injectable`,\n      // which would require switching from `ts_library` to `ng_module`. This change\n      // would also necessitate various patches of `@angular/bazel` to support ESM.\n      useFactory: () => new Console()\n    }, {\n      provide: _ENABLE_ROOT_COMPONENT_BOOTSTRAP,\n      useValue: false\n    }]);\n    try {\n      let applicationRef;\n      if (isNgModule(bootstrap)) {\n        const moduleRef = yield platformRef.bootstrapModule(bootstrap);\n        applicationRef = moduleRef.injector.get(ApplicationRef);\n      } else {\n        applicationRef = yield bootstrap();\n      }\n      const injector = applicationRef.injector;\n      const router = injector.get(Router);\n      // Workaround to unblock navigation when `withEnabledBlockingInitialNavigation()` is used.\n      // This is necessary because route extraction disables component bootstrapping.\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      router.navigationTransitions.afterPreactivation()?.next?.();\n      // Wait until the application is stable.\n      yield applicationRef.whenStable();\n      const errors = [];\n      const rawBaseHref = injector.get(APP_BASE_HREF, null, {\n        optional: true\n      }) ?? injector.get(PlatformLocation).getBaseHrefFromDOM();\n      const {\n        pathname: baseHref\n      } = new URL(rawBaseHref, 'http://localhost');\n      const compiler = injector.get(Compiler);\n      const serverRoutesConfig = injector.get(SERVER_ROUTES_CONFIG, null, {\n        optional: true\n      });\n      let serverConfigRouteTree;\n      if (serverRoutesConfig) {\n        const result = buildServerConfigRouteTree(serverRoutesConfig);\n        serverConfigRouteTree = result.serverConfigRouteTree;\n        errors.push(...result.errors);\n      }\n      if (errors.length) {\n        return {\n          baseHref,\n          routes: [],\n          errors\n        };\n      }\n      const routesResults = [];\n      if (router.config.length) {\n        // Retrieve all routes from the Angular router configuration.\n        const traverseRoutes = traverseRoutesConfig({\n          routes: router.config,\n          compiler,\n          parentInjector: injector,\n          parentRoute: '',\n          serverConfigRouteTree,\n          invokeGetPrerenderParams,\n          includePrerenderFallbackRoutes,\n          entryPointToBrowserMapping\n        });\n        const seenRoutes = new Set();\n        var _iteratorAbruptCompletion = false;\n        var _didIteratorError = false;\n        var _iteratorError;\n        try {\n          for (var _iterator = _asyncIterator(traverseRoutes), _step; _iteratorAbruptCompletion = !(_step = yield _iterator.next()).done; _iteratorAbruptCompletion = false) {\n            const routeMetadata = _step.value;\n            {\n              if ('error' in routeMetadata) {\n                errors.push(routeMetadata.error);\n                continue;\n              }\n              // If a result already exists for the exact same route, subsequent matches should be ignored.\n              // This aligns with Angular's app router behavior, which prioritizes the first route.\n              const routePath = routeMetadata.route;\n              if (!seenRoutes.has(routePath)) {\n                routesResults.push(routeMetadata);\n                seenRoutes.add(routePath);\n              }\n            }\n          }\n          // This timeout is necessary to prevent 'adev' from hanging in production builds.\n          // The exact cause is unclear, but removing it leads to the issue.\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (_iteratorAbruptCompletion && _iterator.return != null) {\n              yield _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n        yield new Promise(resolve => setTimeout(resolve, 0));\n        if (serverConfigRouteTree) {\n          for (const {\n            route,\n            presentInClientRouter\n          } of serverConfigRouteTree.traverse()) {\n            if (presentInClientRouter || route.endsWith('/**')) {\n              // Skip if matched or it's the catch-all route.\n              continue;\n            }\n            errors.push(`The '${stripLeadingSlash(route)}' server route does not match any routes defined in the Angular ` + `routing configuration (typically provided as a part of the 'provideRouter' call). ` + 'Please make sure that the mentioned server route is present in the Angular routing configuration.');\n          }\n        }\n      } else {\n        const rootRouteMetadata = serverConfigRouteTree?.match('') ?? {\n          route: '',\n          renderMode: RenderMode.Prerender\n        };\n        routesResults.push({\n          ...rootRouteMetadata,\n          // Matched route might be `/*` or `/**`, which would make Angular serve all routes rather than just `/`.\n          // So we limit to just `/` for the empty app router case.\n          route: ''\n        });\n      }\n      return {\n        baseHref,\n        routes: routesResults,\n        errors,\n        appShellRoute: serverRoutesConfig?.appShellRoute\n      };\n    } finally {\n      platformRef.destroy();\n    }\n  });\n  return _getRoutesFromAngularRouterConfig.apply(this, arguments);\n}\nfunction extractRoutesAndCreateRouteTree(options) {\n  const {\n    url,\n    manifest = getAngularAppManifest(),\n    invokeGetPrerenderParams = false,\n    includePrerenderFallbackRoutes = true,\n    signal\n  } = options;\n  function extract() {\n    return _extract.apply(this, arguments);\n  }\n  function _extract() {\n    _extract = _asyncToGenerator(function* () {\n      const routeTree = new RouteTree();\n      const document = yield new ServerAssets(manifest).getIndexServerHtml().text();\n      const bootstrap = yield manifest.bootstrap();\n      const {\n        baseHref,\n        appShellRoute,\n        routes,\n        errors\n      } = yield getRoutesFromAngularRouterConfig(bootstrap, document, url, invokeGetPrerenderParams, includePrerenderFallbackRoutes, manifest.entryPointToBrowserMapping);\n      for (const {\n        route,\n        ...metadata\n      } of routes) {\n        if (metadata.redirectTo !== undefined) {\n          metadata.redirectTo = joinUrlParts(baseHref, metadata.redirectTo);\n        }\n        // Remove undefined fields\n        // Helps avoid unnecessary test updates\n        for (const [key, value] of Object.entries(metadata)) {\n          if (value === undefined) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            delete metadata[key];\n          }\n        }\n        const fullRoute = joinUrlParts(baseHref, route);\n        routeTree.insert(fullRoute, metadata);\n      }\n      return {\n        appShellRoute,\n        routeTree,\n        errors\n      };\n    });\n    return _extract.apply(this, arguments);\n  }\n  return signal ? promiseWithAbort(extract(), signal, 'Routes extraction') : extract();\n}\n\n/**\r\n * Manages a collection of hooks and provides methods to register and execute them.\r\n * Hooks are functions that can be invoked with specific arguments to allow modifications or enhancements.\r\n */\nclass Hooks {\n  /**\r\n   * A map of hook names to arrays of hook functions.\r\n   * Each hook name can have multiple associated functions, which are executed in sequence.\r\n   */\n  store = /*#__PURE__*/new Map();\n  /**\r\n   * Executes all hooks associated with the specified name, passing the given argument to each hook function.\r\n   * The hooks are invoked sequentially, and the argument may be modified by each hook.\r\n   *\r\n   * @template Hook - The type of the hook name. It should be one of the keys of `HooksMapping`.\r\n   * @param name - The name of the hook whose functions will be executed.\r\n   * @param context - The input value to be passed to each hook function. The value is mutated by each hook function.\r\n   * @returns A promise that resolves once all hook functions have been executed.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const hooks = new Hooks();\r\n   * hooks.on('html:transform:pre', async (ctx) => {\r\n   *   ctx.html = ctx.html.replace(/foo/g, 'bar');\r\n   *   return ctx.html;\r\n   * });\r\n   * const result = await hooks.run('html:transform:pre', { html: '<div>foo</div>' });\r\n   * console.log(result); // '<div>bar</div>'\r\n   * ```\r\n   * @internal\r\n   */\n  run(name, context) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const hooks = _this.store.get(name);\n      switch (name) {\n        case 'html:transform:pre':\n          {\n            if (!hooks) {\n              return context.html;\n            }\n            const ctx = {\n              ...context\n            };\n            for (const hook of hooks) {\n              ctx.html = yield hook(ctx);\n            }\n            return ctx.html;\n          }\n        default:\n          throw new Error(`Running hook \"${name}\" is not supported.`);\n      }\n    })();\n  }\n  /**\r\n   * Registers a new hook function under the specified hook name.\r\n   * This function should be a function that takes an argument of type `T` and returns a `string` or `Promise<string>`.\r\n   *\r\n   * @template Hook - The type of the hook name. It should be one of the keys of `HooksMapping`.\r\n   * @param name - The name of the hook under which the function will be registered.\r\n   * @param handler - A function to be executed when the hook is triggered. The handler will be called with an argument\r\n   *                  that may be modified by the hook functions.\r\n   *\r\n   * @remarks\r\n   * - If there are existing handlers registered under the given hook name, the new handler will be added to the list.\r\n   * - If no handlers are registered under the given hook name, a new list will be created with the handler as its first element.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * hooks.on('html:transform:pre', async (ctx) => {\r\n   *   return ctx.html.replace(/foo/g, 'bar');\r\n   * });\r\n   * ```\r\n   */\n  on(name, handler) {\n    const hooks = this.store.get(name);\n    if (hooks) {\n      hooks.push(handler);\n    } else {\n      this.store.set(name, [handler]);\n    }\n  }\n  /**\r\n   * Checks if there are any hooks registered under the specified name.\r\n   *\r\n   * @param name - The name of the hook to check.\r\n   * @returns `true` if there are hooks registered under the specified name, otherwise `false`.\r\n   */\n  has(name) {\n    return !!this.store.get(name)?.length;\n  }\n}\n\n/**\r\n * Manages the application's server routing logic by building and maintaining a route tree.\r\n *\r\n * This class is responsible for constructing the route tree from the Angular application\r\n * configuration and using it to match incoming requests to the appropriate routes.\r\n */\nclass ServerRouter {\n  routeTree;\n  /**\r\n   * Creates an instance of the `ServerRouter`.\r\n   *\r\n   * @param routeTree - An instance of `RouteTree` that holds the routing information.\r\n   * The `RouteTree` is used to match request URLs to the appropriate route metadata.\r\n   */\n  constructor(routeTree) {\n    this.routeTree = routeTree;\n  }\n  /**\r\n   * Static property to track the ongoing build promise.\r\n   */\n  static #extractionPromise;\n  /**\r\n   * Creates or retrieves a `ServerRouter` instance based on the provided manifest and URL.\r\n   *\r\n   * If the manifest contains pre-built routes, a new `ServerRouter` is immediately created.\r\n   * Otherwise, it builds the router by extracting routes from the Angular configuration\r\n   * asynchronously. This method ensures that concurrent builds are prevented by re-using\r\n   * the same promise.\r\n   *\r\n   * @param manifest - An instance of `AngularAppManifest` that contains the route information.\r\n   * @param url - The URL for server-side rendering. The URL is needed to configure `ServerPlatformLocation`.\r\n   * This is necessary to ensure that API requests for relative paths succeed, which is crucial for correct route extraction.\r\n   * [Reference](https://github.com/angular/angular/blob/d608b857c689d17a7ffa33bbb510301014d24a17/packages/platform-server/src/location.ts#L51)\r\n   * @returns A promise resolving to a `ServerRouter` instance.\r\n   */\n  static from(manifest, url) {\n    if (manifest.routes) {\n      const routeTree = RouteTree.fromObject(manifest.routes);\n      return Promise.resolve(new ServerRouter(routeTree));\n    }\n    // Create and store a new promise for the build process.\n    // This prevents concurrent builds by re-using the same promise.\n    ServerRouter.#extractionPromise ??= extractRoutesAndCreateRouteTree({\n      url,\n      manifest\n    }).then(({\n      routeTree,\n      errors\n    }) => {\n      if (errors.length > 0) {\n        throw new Error('Error(s) occurred while extracting routes:\\n' + errors.map(error => `- ${error}`).join('\\n'));\n      }\n      return new ServerRouter(routeTree);\n    }).finally(() => {\n      ServerRouter.#extractionPromise = undefined;\n    });\n    return ServerRouter.#extractionPromise;\n  }\n  /**\r\n   * Matches a request URL against the route tree to retrieve route metadata.\r\n   *\r\n   * This method strips 'index.html' from the URL if it is present and then attempts\r\n   * to find a match in the route tree. If a match is found, it returns the associated\r\n   * route metadata; otherwise, it returns `undefined`.\r\n   *\r\n   * @param url - The URL to be matched against the route tree.\r\n   * @returns The metadata for the matched route or `undefined` if no match is found.\r\n   */\n  match(url) {\n    // Strip 'index.html' from URL if present.\n    // A request to `http://www.example.com/page/index.html` will render the Angular route corresponding to `http://www.example.com/page`.\n    const {\n      pathname\n    } = stripIndexHtmlFromURL(url);\n    return this.routeTree.match(decodeURIComponent(pathname));\n  }\n}\n\n/**\r\n * Generates a SHA-256 hash of the provided string.\r\n *\r\n * @param data - The input string to be hashed.\r\n * @returns A promise that resolves to the SHA-256 hash of the input,\r\n * represented as a hexadecimal string.\r\n */\nfunction sha256(_x10) {\n  return _sha.apply(this, arguments);\n}\n/**\r\n * Pattern used to extract the media query set by Beasties in an `onload` handler.\r\n */\nfunction _sha() {\n  _sha = _asyncToGenerator(function* (data) {\n    const encodedData = new TextEncoder().encode(data);\n    const hashBuffer = yield crypto.subtle.digest('SHA-256', encodedData);\n    const hashParts = [];\n    for (const h of new Uint8Array(hashBuffer)) {\n      hashParts.push(h.toString(16).padStart(2, '0'));\n    }\n    return hashParts.join('');\n  });\n  return _sha.apply(this, arguments);\n}\nconst MEDIA_SET_HANDLER_PATTERN = /^this\\.media=[\"'](.*)[\"'];?$/;\n/**\r\n * Name of the attribute used to save the Beasties media query so it can be re-assigned on load.\r\n */\nconst CSP_MEDIA_ATTR = 'ngCspMedia';\n/**\r\n * Script that dynamically updates the `media` attribute of `<link>` tags based on a custom attribute (`CSP_MEDIA_ATTR`).\r\n *\r\n * NOTE:\r\n * We do not use `document.querySelectorAll('link').forEach((s) => s.addEventListener('load', ...)`\r\n * because load events are not always triggered reliably on Chrome.\r\n * See: https://github.com/angular/angular-cli/issues/26932 and https://crbug.com/1521256\r\n *\r\n * The script:\r\n * - Ensures the event target is a `<link>` tag with the `CSP_MEDIA_ATTR` attribute.\r\n * - Updates the `media` attribute with the value of `CSP_MEDIA_ATTR` and then removes the attribute.\r\n * - Removes the event listener when all relevant `<link>` tags have been processed.\r\n * - Uses event capturing (the `true` parameter) since load events do not bubble up the DOM.\r\n */\nconst LINK_LOAD_SCRIPT_CONTENT = /* @__PURE__ */(() => `(() => {\n  const CSP_MEDIA_ATTR = '${CSP_MEDIA_ATTR}';\n  const documentElement = document.documentElement;\n\n  // Listener for load events on link tags.\n  const listener = (e) => {\n    const target = e.target;\n    if (\n      !target ||\n      target.tagName !== 'LINK' ||\n      !target.hasAttribute(CSP_MEDIA_ATTR)\n    ) {\n      return;\n    }\n\n    target.media = target.getAttribute(CSP_MEDIA_ATTR);\n    target.removeAttribute(CSP_MEDIA_ATTR);\n\n    if (!document.head.querySelector(\\`link[\\${CSP_MEDIA_ATTR}]\\`)) {\n      documentElement.removeEventListener('load', listener);\n    }\n  };\n\n  documentElement.addEventListener('load', listener, true);\n})();`)();\nclass BeastiesBase extends Beasties {}\n/* eslint-enable @typescript-eslint/no-unsafe-declaration-merging */\nclass InlineCriticalCssProcessor extends BeastiesBase {\n  readFile;\n  outputPath;\n  addedCspScriptsDocuments = /*#__PURE__*/new WeakSet();\n  documentNonces = /*#__PURE__*/new WeakMap();\n  constructor(readFile, outputPath) {\n    super({\n      logger: {\n        // eslint-disable-next-line no-console\n        warn: s => console.warn(s),\n        // eslint-disable-next-line no-console\n        error: s => console.error(s),\n        info: () => {}\n      },\n      logLevel: 'warn',\n      path: outputPath,\n      publicPath: undefined,\n      compress: false,\n      pruneSource: false,\n      reduceInlineStyles: false,\n      mergeStylesheets: false,\n      // Note: if `preload` changes to anything other than `media`, the logic in\n      // `embedLinkedStylesheet` will have to be updated.\n      preload: 'media',\n      noscriptFallback: true,\n      inlineFonts: true\n    });\n    this.readFile = readFile;\n    this.outputPath = outputPath;\n  }\n  /**\r\n   * Override of the Beasties `embedLinkedStylesheet` method\r\n   * that makes it work with Angular's CSP APIs.\r\n   */\n  embedLinkedStylesheet(link, document) {\n    var _superprop_getEmbedLinkedStylesheet = () => super.embedLinkedStylesheet,\n      _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (link.getAttribute('media') === 'print' && link.next?.name === 'noscript') {\n        // Workaround for https://github.com/GoogleChromeLabs/critters/issues/64\n        // NB: this is only needed for the webpack based builders.\n        const media = link.getAttribute('onload')?.match(MEDIA_SET_HANDLER_PATTERN);\n        if (media) {\n          link.removeAttribute('onload');\n          link.setAttribute('media', media[1]);\n          link?.next?.remove();\n        }\n      }\n      const returnValue = yield _superprop_getEmbedLinkedStylesheet().call(_this2, link, document);\n      const cspNonce = _this2.findCspNonce(document);\n      if (cspNonce) {\n        const beastiesMedia = link.getAttribute('onload')?.match(MEDIA_SET_HANDLER_PATTERN);\n        if (beastiesMedia) {\n          // If there's a Beasties-generated `onload` handler and the file has an Angular CSP nonce,\n          // we have to remove the handler, because it's incompatible with CSP. We save the value\n          // in a different attribute and we generate a script tag with the nonce that uses\n          // `addEventListener` to apply the media query instead.\n          link.removeAttribute('onload');\n          link.setAttribute(CSP_MEDIA_ATTR, beastiesMedia[1]);\n          _this2.conditionallyInsertCspLoadingScript(document, cspNonce, link);\n        }\n        // Ideally we would hook in at the time Beasties inserts the `style` tags, but there isn't\n        // a way of doing that at the moment so we fall back to doing it any time a `link` tag is\n        // inserted. We mitigate it by only iterating the direct children of the `<head>` which\n        // should be pretty shallow.\n        document.head.children.forEach(child => {\n          if (child.tagName === 'style' && !child.hasAttribute('nonce')) {\n            child.setAttribute('nonce', cspNonce);\n          }\n        });\n      }\n      return returnValue;\n    })();\n  }\n  /**\r\n   * Finds the CSP nonce for a specific document.\r\n   */\n  findCspNonce(document) {\n    if (this.documentNonces.has(document)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return this.documentNonces.get(document);\n    }\n    // HTML attribute are case-insensitive, but the parser used by Beasties is case-sensitive.\n    const nonceElement = document.querySelector('[ngCspNonce], [ngcspnonce]');\n    const cspNonce = nonceElement?.getAttribute('ngCspNonce') || nonceElement?.getAttribute('ngcspnonce') || null;\n    this.documentNonces.set(document, cspNonce);\n    return cspNonce;\n  }\n  /**\r\n   * Inserts the `script` tag that swaps the critical CSS at runtime,\r\n   * if one hasn't been inserted into the document already.\r\n   */\n  conditionallyInsertCspLoadingScript(document, nonce, link) {\n    if (this.addedCspScriptsDocuments.has(document)) {\n      return;\n    }\n    if (document.head.textContent.includes(LINK_LOAD_SCRIPT_CONTENT)) {\n      // Script was already added during the build.\n      this.addedCspScriptsDocuments.add(document);\n      return;\n    }\n    const script = document.createElement('script');\n    script.setAttribute('nonce', nonce);\n    script.textContent = LINK_LOAD_SCRIPT_CONTENT;\n    // Prepend the script to the head since it needs to\n    // run as early as possible, before the `link` tags.\n    document.head.insertBefore(script, link);\n    this.addedCspScriptsDocuments.add(document);\n  }\n}\n\n/**\r\n * A Least Recently Used (LRU) cache implementation.\r\n *\r\n * This cache stores a fixed number of key-value pairs, and when the cache exceeds its capacity,\r\n * the least recently accessed items are evicted.\r\n *\r\n * @template Key - The type of the cache keys.\r\n * @template Value - The type of the cache values.\r\n */\nclass LRUCache {\n  /**\r\n   * The maximum number of items the cache can hold.\r\n   */\n  capacity;\n  /**\r\n   * Internal storage for the cache, mapping keys to their associated nodes in the linked list.\r\n   */\n  cache = /*#__PURE__*/new Map();\n  /**\r\n   * Head of the doubly linked list, representing the most recently used item.\r\n   */\n  head;\n  /**\r\n   * Tail of the doubly linked list, representing the least recently used item.\r\n   */\n  tail;\n  /**\r\n   * Creates a new LRUCache instance.\r\n   * @param capacity The maximum number of items the cache can hold.\r\n   */\n  constructor(capacity) {\n    this.capacity = capacity;\n  }\n  /**\r\n   * Gets the value associated with the given key.\r\n   * @param key The key to retrieve the value for.\r\n   * @returns The value associated with the key, or undefined if the key is not found.\r\n   */\n  get(key) {\n    const node = this.cache.get(key);\n    if (node) {\n      this.moveToHead(node);\n      return node.value;\n    }\n    return undefined;\n  }\n  /**\r\n   * Puts a key-value pair into the cache.\r\n   * If the key already exists, the value is updated.\r\n   * If the cache is full, the least recently used item is evicted.\r\n   * @param key The key to insert or update.\r\n   * @param value The value to associate with the key.\r\n   */\n  put(key, value) {\n    const cachedNode = this.cache.get(key);\n    if (cachedNode) {\n      // Update existing node\n      cachedNode.value = value;\n      this.moveToHead(cachedNode);\n      return;\n    }\n    // Create a new node\n    const newNode = {\n      key,\n      value,\n      prev: undefined,\n      next: undefined\n    };\n    this.cache.set(key, newNode);\n    this.addToHead(newNode);\n    if (this.cache.size > this.capacity) {\n      // Evict the LRU item\n      const tail = this.removeTail();\n      if (tail) {\n        this.cache.delete(tail.key);\n      }\n    }\n  }\n  /**\r\n   * Adds a node to the head of the linked list.\r\n   * @param node The node to add.\r\n   */\n  addToHead(node) {\n    node.next = this.head;\n    node.prev = undefined;\n    if (this.head) {\n      this.head.prev = node;\n    }\n    this.head = node;\n    if (!this.tail) {\n      this.tail = node;\n    }\n  }\n  /**\r\n   * Removes a node from the linked list.\r\n   * @param node The node to remove.\r\n   */\n  removeNode(node) {\n    if (node.prev) {\n      node.prev.next = node.next;\n    } else {\n      this.head = node.next;\n    }\n    if (node.next) {\n      node.next.prev = node.prev;\n    } else {\n      this.tail = node.prev;\n    }\n  }\n  /**\r\n   * Moves a node to the head of the linked list.\r\n   * @param node The node to move.\r\n   */\n  moveToHead(node) {\n    this.removeNode(node);\n    this.addToHead(node);\n  }\n  /**\r\n   * Removes the tail node from the linked list.\r\n   * @returns The removed tail node, or undefined if the list is empty.\r\n   */\n  removeTail() {\n    const node = this.tail;\n    if (node) {\n      this.removeNode(node);\n    }\n    return node;\n  }\n}\n\n/**\r\n * Maximum number of critical CSS entries the cache can store.\r\n * This value determines the capacity of the LRU (Least Recently Used) cache, which stores critical CSS for pages.\r\n */\nconst MAX_INLINE_CSS_CACHE_ENTRIES = 50;\n/**\r\n * A mapping of `RenderMode` enum values to corresponding string representations.\r\n *\r\n * This record is used to map each `RenderMode` to a specific string value that represents\r\n * the server context. The string values are used internally to differentiate\r\n * between various rendering strategies when processing routes.\r\n *\r\n * - `RenderMode.Prerender` maps to `'ssg'` (Static Site Generation).\r\n * - `RenderMode.Server` maps to `'ssr'` (Server-Side Rendering).\r\n * - `RenderMode.Client` maps to an empty string `''` (Client-Side Rendering, no server context needed).\r\n */\nconst SERVER_CONTEXT_VALUE = {\n  [RenderMode.Prerender]: 'ssg',\n  [RenderMode.Server]: 'ssr',\n  [RenderMode.Client]: ''\n};\n/**\r\n * Represents a locale-specific Angular server application managed by the server application engine.\r\n *\r\n * The `AngularServerApp` class handles server-side rendering and asset management for a specific locale.\r\n */\nclass AngularServerApp {\n  options;\n  /**\r\n   * Whether prerendered routes should be rendered on demand or served directly.\r\n   *\r\n   * @see {@link AngularServerAppOptions.allowStaticRouteRender} for more details.\r\n   */\n  allowStaticRouteRender;\n  /**\r\n   * Hooks for extending or modifying server behavior.\r\n   *\r\n   * @see {@link AngularServerAppOptions.hooks} for more details.\r\n   */\n  hooks;\n  /**\r\n   * Constructs an instance of `AngularServerApp`.\r\n   *\r\n   * @param options Optional configuration options for the server application.\r\n   */\n  constructor(options = {}) {\n    this.options = options;\n    this.allowStaticRouteRender = this.options.allowStaticRouteRender ?? false;\n    this.hooks = options.hooks ?? new Hooks();\n  }\n  /**\r\n   * The manifest associated with this server application.\r\n   */\n  manifest = /*#__PURE__*/getAngularAppManifest();\n  /**\r\n   * An instance of ServerAsset that handles server-side asset.\r\n   */\n  assets = /*#__PURE__*/new ServerAssets(this.manifest);\n  /**\r\n   * The router instance used for route matching and handling.\r\n   */\n  router;\n  /**\r\n   * The `inlineCriticalCssProcessor` is responsible for handling critical CSS inlining.\r\n   */\n  inlineCriticalCssProcessor;\n  /**\r\n   * The bootstrap mechanism for the server application.\r\n   */\n  boostrap;\n  /**\r\n   * Cache for storing critical CSS for pages.\r\n   * Stores a maximum of MAX_INLINE_CSS_CACHE_ENTRIES entries.\r\n   *\r\n   * Uses an LRU (Least Recently Used) eviction policy, meaning that when the cache is full,\r\n   * the least recently accessed page's critical CSS will be removed to make space for new entries.\r\n   */\n  criticalCssLRUCache = /*#__PURE__*/new LRUCache(MAX_INLINE_CSS_CACHE_ENTRIES);\n  /**\r\n   * Handles an incoming HTTP request by serving prerendered content, performing server-side rendering,\r\n   * or delivering a static file for client-side rendered routes based on the `RenderMode` setting.\r\n   *\r\n   * @param request - The HTTP request to handle.\r\n   * @param requestContext - Optional context for rendering, such as metadata associated with the request.\r\n   * @returns A promise that resolves to the resulting HTTP response object, or `null` if no matching Angular route is found.\r\n   *\r\n   * @remarks A request to `https://www.example.com/page/index.html` will serve or render the Angular route\r\n   * corresponding to `https://www.example.com/page`.\r\n   */\n  handle(request, requestContext) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const url = new URL(request.url);\n      _this3.router ??= yield ServerRouter.from(_this3.manifest, url);\n      const matchedRoute = _this3.router.match(url);\n      if (!matchedRoute) {\n        // Not a known Angular route.\n        return null;\n      }\n      const {\n        redirectTo,\n        status,\n        renderMode\n      } = matchedRoute;\n      if (redirectTo !== undefined) {\n        return new Response(null, {\n          // Note: The status code is validated during route extraction.\n          // 302 Found is used by default for redirections\n          // See: https://developer.mozilla.org/en-US/docs/Web/API/Response/redirect_static#status\n          status: status ?? 302,\n          headers: {\n            'Location': buildPathWithParams(redirectTo, url.pathname)\n          }\n        });\n      }\n      if (renderMode === RenderMode.Prerender) {\n        const response = yield _this3.handleServe(request, matchedRoute);\n        if (response) {\n          return response;\n        }\n      }\n      return promiseWithAbort(_this3.handleRendering(request, matchedRoute, requestContext), request.signal, `Request for: ${request.url}`);\n    })();\n  }\n  /**\r\n   * Handles serving a prerendered static asset if available for the matched route.\r\n   *\r\n   * This method only supports `GET` and `HEAD` requests.\r\n   *\r\n   * @param request - The incoming HTTP request for serving a static page.\r\n   * @param matchedRoute - The metadata of the matched route for rendering.\r\n   * If not provided, the method attempts to find a matching route based on the request URL.\r\n   * @returns A promise that resolves to a `Response` object if the prerendered page is found, or `null`.\r\n   */\n  handleServe(request, matchedRoute) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        headers,\n        renderMode\n      } = matchedRoute;\n      if (renderMode !== RenderMode.Prerender) {\n        return null;\n      }\n      const {\n        method\n      } = request;\n      if (method !== 'GET' && method !== 'HEAD') {\n        return null;\n      }\n      const assetPath = _this4.buildServerAssetPathFromRequest(request);\n      const {\n        manifest: {\n          locale\n        },\n        assets\n      } = _this4;\n      if (!assets.hasServerAsset(assetPath)) {\n        return null;\n      }\n      const {\n        text,\n        hash,\n        size\n      } = assets.getServerAsset(assetPath);\n      const etag = `\"${hash}\"`;\n      return request.headers.get('if-none-match') === etag ? new Response(undefined, {\n        status: 304,\n        statusText: 'Not Modified'\n      }) : new Response(yield text(), {\n        headers: {\n          'Content-Length': size.toString(),\n          'ETag': etag,\n          'Content-Type': 'text/html;charset=UTF-8',\n          ...(locale !== undefined ? {\n            'Content-Language': locale\n          } : {}),\n          ...headers\n        }\n      });\n    })();\n  }\n  /**\r\n   * Handles the server-side rendering process for the given HTTP request.\r\n   * This method matches the request URL to a route and performs rendering if a matching route is found.\r\n   *\r\n   * @param request - The incoming HTTP request to be processed.\r\n   * @param matchedRoute - The metadata of the matched route for rendering.\r\n   * If not provided, the method attempts to find a matching route based on the request URL.\r\n   * @param requestContext - Optional additional context for rendering, such as request metadata.\r\n   *\r\n   * @returns A promise that resolves to the rendered response, or null if no matching route is found.\r\n   */\n  handleRendering(request, matchedRoute, requestContext) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        renderMode,\n        headers,\n        status,\n        preload\n      } = matchedRoute;\n      if (!_this5.allowStaticRouteRender && renderMode === RenderMode.Prerender) {\n        return null;\n      }\n      const url = new URL(request.url);\n      const platformProviders = [];\n      const {\n        manifest: {\n          bootstrap,\n          inlineCriticalCss,\n          locale\n        },\n        assets\n      } = _this5;\n      // Initialize the response with status and headers if available.\n      const responseInit = {\n        status,\n        headers: new Headers({\n          'Content-Type': 'text/html;charset=UTF-8',\n          ...(locale !== undefined ? {\n            'Content-Language': locale\n          } : {}),\n          ...headers\n        })\n      };\n      if (renderMode === RenderMode.Server) {\n        // Configure platform providers for request and response only for SSR.\n        platformProviders.push({\n          provide: REQUEST,\n          useValue: request\n        }, {\n          provide: REQUEST_CONTEXT,\n          useValue: requestContext\n        }, {\n          provide: RESPONSE_INIT,\n          useValue: responseInit\n        });\n      } else if (renderMode === RenderMode.Client) {\n        // Serve the client-side rendered version if the route is configured for CSR.\n        let html = yield _this5.assets.getServerAsset('index.csr.html').text();\n        html = yield _this5.runTransformsOnHtml(html, url, preload);\n        return new Response(html, responseInit);\n      }\n      if (locale !== undefined) {\n        platformProviders.push({\n          provide: LOCALE_ID,\n          useValue: locale\n        });\n      }\n      _this5.boostrap ??= yield bootstrap();\n      let html = yield assets.getIndexServerHtml().text();\n      html = yield _this5.runTransformsOnHtml(html, url, preload);\n      html = yield renderAngular(html, _this5.boostrap, url, platformProviders, SERVER_CONTEXT_VALUE[renderMode]);\n      if (inlineCriticalCss) {\n        // Optionally inline critical CSS.\n        _this5.inlineCriticalCssProcessor ??= new InlineCriticalCssProcessor(path => {\n          const fileName = path.split('/').pop() ?? path;\n          return _this5.assets.getServerAsset(fileName).text();\n        });\n        // TODO(alanagius): remove once Node.js version 18 is no longer supported.\n        if (renderMode === RenderMode.Server && typeof crypto === 'undefined') {\n          // eslint-disable-next-line no-console\n          console.error(`The global 'crypto' module is unavailable. ` + `If you are running on Node.js, please ensure you are using version 20 or later, ` + `which includes built-in support for the Web Crypto module.`);\n        }\n        if (renderMode === RenderMode.Server && typeof crypto !== 'undefined') {\n          // Only cache if we are running in SSR Mode.\n          const cacheKey = yield sha256(html);\n          let htmlWithCriticalCss = _this5.criticalCssLRUCache.get(cacheKey);\n          if (htmlWithCriticalCss === undefined) {\n            htmlWithCriticalCss = yield _this5.inlineCriticalCssProcessor.process(html);\n            _this5.criticalCssLRUCache.put(cacheKey, htmlWithCriticalCss);\n          }\n          html = htmlWithCriticalCss;\n        } else {\n          html = yield _this5.inlineCriticalCssProcessor.process(html);\n        }\n      }\n      return new Response(html, responseInit);\n    })();\n  }\n  /**\r\n   * Constructs the asset path on the server based on the provided HTTP request.\r\n   *\r\n   * This method processes the incoming request URL to derive a path corresponding\r\n   * to the requested asset. It ensures the path points to the correct file (e.g.,\r\n   * `index.html`) and removes any base href if it is not part of the asset path.\r\n   *\r\n   * @param request - The incoming HTTP request object.\r\n   * @returns The server-relative asset path derived from the request.\r\n   */\n  buildServerAssetPathFromRequest(request) {\n    let {\n      pathname: assetPath\n    } = new URL(request.url);\n    if (!assetPath.endsWith('/index.html')) {\n      // Append \"index.html\" to build the default asset path.\n      assetPath = joinUrlParts(assetPath, 'index.html');\n    }\n    const {\n      baseHref\n    } = this.manifest;\n    // Check if the asset path starts with the base href and the base href is not (`/` or ``).\n    if (baseHref.length > 1 && assetPath.startsWith(baseHref)) {\n      // Remove the base href from the start of the asset path to align with server-asset expectations.\n      assetPath = assetPath.slice(baseHref.length);\n    }\n    return stripLeadingSlash(assetPath);\n  }\n  /**\r\n   * Runs the registered transform hooks on the given HTML content.\r\n   *\r\n   * @param html - The raw HTML content to be transformed.\r\n   * @param url - The URL associated with the HTML content, used for context during transformations.\r\n   * @param preload - An array of URLs representing the JavaScript resources to preload.\r\n   * @returns A promise that resolves to the transformed HTML string.\r\n   */\n  runTransformsOnHtml(html, url, preload) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      if (_this6.hooks.has('html:transform:pre')) {\n        html = yield _this6.hooks.run('html:transform:pre', {\n          html,\n          url\n        });\n      }\n      if (preload?.length) {\n        html = appendPreloadHintsToHtml(html, preload);\n      }\n      return html;\n    })();\n  }\n}\nlet angularServerApp;\n/**\r\n * Retrieves or creates an instance of `AngularServerApp`.\r\n * - If an instance of `AngularServerApp` already exists, it will return the existing one.\r\n * - If no instance exists, it will create a new one with the provided options.\r\n *\r\n * @param options Optional configuration options for the server application.\r\n *\r\n * @returns The existing or newly created instance of `AngularServerApp`.\r\n */\nfunction getOrCreateAngularServerApp(options) {\n  return angularServerApp ??= new AngularServerApp(options);\n}\n/**\r\n * Destroys the existing `AngularServerApp` instance, releasing associated resources and resetting the\r\n * reference to `undefined`.\r\n *\r\n * This function is primarily used to enable the recreation of the `AngularServerApp` instance,\r\n * typically when server configuration or application state needs to be refreshed.\r\n */\nfunction destroyAngularServerApp() {\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    // Need to clean up GENERATED_COMP_IDS map in `@angular/core`.\n    // Otherwise an incorrect component ID generation collision detected warning will be displayed in development.\n    // See: https://github.com/angular/angular-cli/issues/25924\n    _resetCompiledComponents();\n  }\n  angularServerApp = undefined;\n}\n/**\r\n * Appends module preload hints to an HTML string for specified JavaScript resources.\r\n * This function enhances the HTML by injecting `<link rel=\"modulepreload\">` elements\r\n * for each provided resource, allowing browsers to preload the specified JavaScript\r\n * modules for better performance.\r\n *\r\n * @param html - The original HTML string to which preload hints will be added.\r\n * @param preload - An array of URLs representing the JavaScript resources to preload.\r\n * @returns The modified HTML string with the preload hints injected before the closing `</body>` tag.\r\n *          If `</body>` is not found, the links are not added.\r\n */\nfunction appendPreloadHintsToHtml(html, preload) {\n  const bodyCloseIdx = html.lastIndexOf('</body>');\n  if (bodyCloseIdx === -1) {\n    return html;\n  }\n  // Note: Module preloads should be placed at the end before the closing body tag to avoid a performance penalty.\n  // Placing them earlier can cause the browser to prioritize downloading these modules\n  // over other critical page resources like images, CSS, and fonts.\n  return [html.slice(0, bodyCloseIdx), ...preload.map(val => `<link rel=\"modulepreload\" href=\"${val}\">`), html.slice(bodyCloseIdx)].join('\\n');\n}\n\n/**\r\n * Extracts a potential locale ID from a given URL based on the specified base path.\r\n *\r\n * This function parses the URL to locate a potential locale identifier that immediately\r\n * follows the base path segment in the URL's pathname. If the URL does not contain a valid\r\n * locale ID, an empty string is returned.\r\n *\r\n * @param url - The full URL from which to extract the locale ID.\r\n * @param basePath - The base path used as the reference point for extracting the locale ID.\r\n * @returns The extracted locale ID if present, or an empty string if no valid locale ID is found.\r\n *\r\n * @example\r\n * ```js\r\n * const url = new URL('https://example.com/base/en/page');\r\n * const basePath = '/base';\r\n * const localeId = getPotentialLocaleIdFromUrl(url, basePath);\r\n * console.log(localeId); // Output: 'en'\r\n * ```\r\n */\nfunction getPotentialLocaleIdFromUrl(url, basePath) {\n  const {\n    pathname\n  } = url;\n  // Move forward of the base path section.\n  let start = basePath.length;\n  if (pathname[start] === '/') {\n    start++;\n  }\n  // Find the next forward slash.\n  let end = pathname.indexOf('/', start);\n  if (end === -1) {\n    end = pathname.length;\n  }\n  // Extract the potential locale id.\n  return pathname.slice(start, end);\n}\n/**\r\n * Parses the `Accept-Language` header and returns a list of locale preferences with their respective quality values.\r\n *\r\n * The `Accept-Language` header is typically a comma-separated list of locales, with optional quality values\r\n * in the form of `q=<value>`. If no quality value is specified, a default quality of `1` is assumed.\r\n * Special case: if the header is `*`, it returns the default locale with a quality of `1`.\r\n *\r\n * @param header - The value of the `Accept-Language` header, typically a comma-separated list of locales\r\n *                  with optional quality values (e.g., `en-US;q=0.8,fr-FR;q=0.9`). If the header is `*`,\r\n *                  it represents a wildcard for any language, returning the default locale.\r\n *\r\n * @returns A `ReadonlyMap` where the key is the locale (e.g., `en-US`, `fr-FR`), and the value is\r\n *          the associated quality value (a number between 0 and 1). If no quality value is provided,\r\n *          a default of `1` is used.\r\n *\r\n * @example\r\n * ```js\r\n * parseLanguageHeader('en-US;q=0.8,fr-FR;q=0.9')\r\n * // returns new Map([['en-US', 0.8], ['fr-FR', 0.9]])\r\n\r\n * parseLanguageHeader('*')\r\n * // returns new Map([['*', 1]])\r\n * ```\r\n */\nfunction parseLanguageHeader(header) {\n  if (header === '*') {\n    return new Map([['*', 1]]);\n  }\n  const parsedValues = header.split(',').map(item => {\n    const [locale, qualityValue] = item.split(';', 2).map(v => v.trim());\n    let quality = qualityValue?.startsWith('q=') ? parseFloat(qualityValue.slice(2)) : undefined;\n    if (typeof quality !== 'number' || isNaN(quality) || quality < 0 || quality > 1) {\n      quality = 1; // Invalid quality value defaults to 1\n    }\n    return [locale, quality];\n  }).sort(([_localeA, qualityA], [_localeB, qualityB]) => qualityB - qualityA);\n  return new Map(parsedValues);\n}\n/**\r\n * Gets the preferred locale based on the highest quality value from the provided `Accept-Language` header\r\n * and the set of available locales.\r\n *\r\n * This function adheres to the HTTP `Accept-Language` header specification as defined in\r\n * [RFC 7231](https://datatracker.ietf.org/doc/html/rfc7231#section-5.3.5), including:\r\n * - Case-insensitive matching of language tags.\r\n * - Quality value handling (e.g., `q=1`, `q=0.8`). If no quality value is provided, it defaults to `q=1`.\r\n * - Prefix matching (e.g., `en` matching `en-US` or `en-GB`).\r\n *\r\n * @param header - The `Accept-Language` header string to parse and evaluate. It may contain multiple\r\n *                 locales with optional quality values, for example: `'en-US;q=0.8,fr-FR;q=0.9'`.\r\n * @param supportedLocales - An array of supported locales (e.g., `['en-US', 'fr-FR']`),\r\n *                           representing the locales available in the application.\r\n * @returns The best matching locale from the supported languages, or `undefined` if no match is found.\r\n *\r\n * @example\r\n * ```js\r\n * getPreferredLocale('en-US;q=0.8,fr-FR;q=0.9', ['en-US', 'fr-FR', 'de-DE'])\r\n * // returns 'fr-FR'\r\n *\r\n * getPreferredLocale('en;q=0.9,fr-FR;q=0.8', ['en-US', 'fr-FR', 'de-DE'])\r\n * // returns 'en-US'\r\n *\r\n * getPreferredLocale('es-ES;q=0.7', ['en-US', 'fr-FR', 'de-DE'])\r\n * // returns undefined\r\n * ```\r\n */\nfunction getPreferredLocale(header, supportedLocales) {\n  if (supportedLocales.length < 2) {\n    return supportedLocales[0];\n  }\n  const parsedLocales = parseLanguageHeader(header);\n  // Handle edge cases:\n  // - No preferred locales provided.\n  // - Only one supported locale.\n  // - Wildcard preference.\n  if (parsedLocales.size === 0 || parsedLocales.size === 1 && parsedLocales.has('*')) {\n    return supportedLocales[0];\n  }\n  // Create a map for case-insensitive lookup of supported locales.\n  // Keys are normalized (lowercase) locale values, values are original casing.\n  const normalizedSupportedLocales = new Map();\n  for (const locale of supportedLocales) {\n    normalizedSupportedLocales.set(normalizeLocale(locale), locale);\n  }\n  // Iterate through parsed locales in descending order of quality.\n  let bestMatch;\n  const qualityZeroNormalizedLocales = new Set();\n  for (const [locale, quality] of parsedLocales) {\n    const normalizedLocale = normalizeLocale(locale);\n    if (quality === 0) {\n      qualityZeroNormalizedLocales.add(normalizedLocale);\n      continue; // Skip locales with quality value of 0.\n    }\n    // Exact match found.\n    if (normalizedSupportedLocales.has(normalizedLocale)) {\n      return normalizedSupportedLocales.get(normalizedLocale);\n    }\n    // If an exact match is not found, try prefix matching (e.g., \"en\" matches \"en-US\").\n    // Store the first prefix match encountered, as it has the highest quality value.\n    if (bestMatch !== undefined) {\n      continue;\n    }\n    const [languagePrefix] = normalizedLocale.split('-', 1);\n    for (const supportedLocale of normalizedSupportedLocales.keys()) {\n      if (supportedLocale.startsWith(languagePrefix)) {\n        bestMatch = normalizedSupportedLocales.get(supportedLocale);\n        break; // No need to continue searching for this locale.\n      }\n    }\n  }\n  if (bestMatch !== undefined) {\n    return bestMatch;\n  }\n  // Return the first locale that is not quality zero.\n  for (const [normalizedLocale, locale] of normalizedSupportedLocales) {\n    if (!qualityZeroNormalizedLocales.has(normalizedLocale)) {\n      return locale;\n    }\n  }\n}\n/**\r\n * Normalizes a locale string by converting it to lowercase.\r\n *\r\n * @param locale - The locale string to normalize.\r\n * @returns The normalized locale string in lowercase.\r\n *\r\n * @example\r\n * ```ts\r\n * const normalized = normalizeLocale('EN-US');\r\n * console.log(normalized); // Output: \"en-us\"\r\n * ```\r\n */\nfunction normalizeLocale(locale) {\n  return locale.toLowerCase();\n}\n\n/**\r\n * Angular server application engine.\r\n * Manages Angular server applications (including localized ones), handles rendering requests,\r\n * and optionally transforms index HTML before rendering.\r\n *\r\n * @remarks This class should be instantiated once and used as a singleton across the server-side\r\n * application to ensure consistent handling of rendering requests and resource management.\r\n *\r\n * @developerPreview\r\n */\nlet AngularAppEngine = /*#__PURE__*/(() => {\n  class AngularAppEngine {\n    /**\r\n     * A flag to enable or disable the rendering of prerendered routes.\r\n     *\r\n     * Typically used during development to avoid prerendering all routes ahead of time,\r\n     * allowing them to be rendered on the fly as requested.\r\n     *\r\n     * @private\r\n     */\n    static ɵallowStaticRouteRender = false;\n    /**\r\n     * Hooks for extending or modifying the behavior of the server application.\r\n     * These hooks are used by the Angular CLI when running the development server and\r\n     * provide extensibility points for the application lifecycle.\r\n     *\r\n     * @private\r\n     */\n    static ɵhooks = /* #__PURE__*/new Hooks();\n    /**\r\n     * The manifest for the server application.\r\n     */\n    manifest = getAngularAppEngineManifest();\n    /**\r\n     * A map of supported locales from the server application's manifest.\r\n     */\n    supportedLocales = Object.keys(this.manifest.supportedLocales);\n    /**\r\n     * A cache that holds entry points, keyed by their potential locale string.\r\n     */\n    entryPointsCache = new Map();\n    /**\r\n     * Handles an incoming HTTP request by serving prerendered content, performing server-side rendering,\r\n     * or delivering a static file for client-side rendered routes based on the `RenderMode` setting.\r\n     *\r\n     * @param request - The HTTP request to handle.\r\n     * @param requestContext - Optional context for rendering, such as metadata associated with the request.\r\n     * @returns A promise that resolves to the resulting HTTP response object, or `null` if no matching Angular route is found.\r\n     *\r\n     * @remarks A request to `https://www.example.com/page/index.html` will serve or render the Angular route\r\n     * corresponding to `https://www.example.com/page`.\r\n     */\n    handle(request, requestContext) {\n      var _this7 = this;\n      return _asyncToGenerator(function* () {\n        const serverApp = yield _this7.getAngularServerAppForRequest(request);\n        if (serverApp) {\n          return serverApp.handle(request, requestContext);\n        }\n        if (_this7.supportedLocales.length > 1) {\n          // Redirect to the preferred language if i18n is enabled.\n          return _this7.redirectBasedOnAcceptLanguage(request);\n        }\n        return null;\n      })();\n    }\n    /**\r\n     * Handles requests for the base path when i18n is enabled.\r\n     * Redirects the user to a locale-specific path based on the `Accept-Language` header.\r\n     *\r\n     * @param request The incoming request.\r\n     * @returns A `Response` object with a 302 redirect, or `null` if i18n is not enabled\r\n     *          or the request is not for the base path.\r\n     */\n    redirectBasedOnAcceptLanguage(request) {\n      const {\n        basePath,\n        supportedLocales\n      } = this.manifest;\n      // If the request is not for the base path, it's not our responsibility to handle it.\n      const {\n        pathname\n      } = new URL(request.url);\n      if (pathname !== basePath) {\n        return null;\n      }\n      // For requests to the base path (typically '/'), attempt to extract the preferred locale\n      // from the 'Accept-Language' header.\n      const preferredLocale = getPreferredLocale(request.headers.get('Accept-Language') || '*', this.supportedLocales);\n      if (preferredLocale) {\n        const subPath = supportedLocales[preferredLocale];\n        if (subPath !== undefined) {\n          return new Response(null, {\n            status: 302,\n            // Use a 302 redirect as language preference may change.\n            headers: {\n              'Location': joinUrlParts(pathname, subPath),\n              'Vary': 'Accept-Language'\n            }\n          });\n        }\n      }\n      return null;\n    }\n    /**\r\n     * Retrieves the Angular server application instance for a given request.\r\n     *\r\n     * This method checks if the request URL corresponds to an Angular application entry point.\r\n     * If so, it initializes or retrieves an instance of the Angular server application for that entry point.\r\n     * Requests that resemble file requests (except for `/index.html`) are skipped.\r\n     *\r\n     * @param request - The incoming HTTP request object.\r\n     * @returns A promise that resolves to an `AngularServerApp` instance if a valid entry point is found,\r\n     * or `null` if no entry point matches the request URL.\r\n     */\n    getAngularServerAppForRequest(request) {\n      var _this8 = this;\n      return _asyncToGenerator(function* () {\n        // Skip if the request looks like a file but not `/index.html`.\n        const url = new URL(request.url);\n        const entryPoint = yield _this8.getEntryPointExportsForUrl(url);\n        if (!entryPoint) {\n          return null;\n        }\n        // Note: Using `instanceof` is not feasible here because `AngularServerApp` will\n        // be located in separate bundles, making `instanceof` checks unreliable.\n        const ɵgetOrCreateAngularServerApp = entryPoint.ɵgetOrCreateAngularServerApp;\n        const serverApp = ɵgetOrCreateAngularServerApp({\n          allowStaticRouteRender: AngularAppEngine.ɵallowStaticRouteRender,\n          hooks: AngularAppEngine.ɵhooks\n        });\n        return serverApp;\n      })();\n    }\n    /**\r\n     * Retrieves the exports for a specific entry point, caching the result.\r\n     *\r\n     * @param potentialLocale - The locale string used to find the corresponding entry point.\r\n     * @returns A promise that resolves to the entry point exports or `undefined` if not found.\r\n     */\n    getEntryPointExports(potentialLocale) {\n      const cachedEntryPoint = this.entryPointsCache.get(potentialLocale);\n      if (cachedEntryPoint) {\n        return cachedEntryPoint;\n      }\n      const {\n        entryPoints\n      } = this.manifest;\n      const entryPoint = entryPoints[potentialLocale];\n      if (!entryPoint) {\n        return undefined;\n      }\n      const entryPointExports = entryPoint();\n      this.entryPointsCache.set(potentialLocale, entryPointExports);\n      return entryPointExports;\n    }\n    /**\r\n     * Retrieves the entry point for a given URL by determining the locale and mapping it to\r\n     * the appropriate application bundle.\r\n     *\r\n     * This method determines the appropriate entry point and locale for rendering the application by examining the URL.\r\n     * If there is only one entry point available, it is returned regardless of the URL.\r\n     * Otherwise, the method extracts a potential locale identifier from the URL and looks up the corresponding entry point.\r\n     *\r\n     * @param url - The URL of the request.\r\n     * @returns A promise that resolves to the entry point exports or `undefined` if not found.\r\n     */\n    getEntryPointExportsForUrl(url) {\n      const {\n        basePath\n      } = this.manifest;\n      if (this.supportedLocales.length === 1) {\n        return this.getEntryPointExports('');\n      }\n      const potentialLocale = getPotentialLocaleIdFromUrl(url, basePath);\n      return this.getEntryPointExports(potentialLocale) ?? this.getEntryPointExports('');\n    }\n  }\n  return AngularAppEngine;\n})();\n/**\r\n * Annotates a request handler function with metadata, marking it as a special\r\n * handler.\r\n *\r\n * @param handler - The request handler function to be annotated.\r\n * @returns The same handler function passed in, with metadata attached.\r\n *\r\n * @example\r\n * Example usage in a Hono application:\r\n * ```ts\r\n * const app = new Hono();\r\n * export default createRequestHandler(app.fetch);\r\n * ```\r\n *\r\n * @example\r\n * Example usage in a H3 application:\r\n * ```ts\r\n * const app = createApp();\r\n * const handler = toWebHandler(app);\r\n * export default createRequestHandler(handler);\r\n * ```\r\n * @developerPreview\r\n */\nfunction createRequestHandler(handler) {\n  handler['__ng_request_handler__'] = true;\n  return handler;\n}\nexport { AngularAppEngine, PrerenderFallback, RenderMode, createRequestHandler, provideServerRoutesConfig, provideServerRouting, withAppShell, InlineCriticalCssProcessor as ɵInlineCriticalCssProcessor, destroyAngularServerApp as ɵdestroyAngularServerApp, extractRoutesAndCreateRouteTree as ɵextractRoutesAndCreateRouteTree, getOrCreateAngularServerApp as ɵgetOrCreateAngularServerApp, getRoutesFromAngularRouterConfig as ɵgetRoutesFromAngularRouterConfig, setAngularAppEngineManifest as ɵsetAngularAppEngineManifest, setAngularAppManifest as ɵsetAngularAppManifest };\n//# sourceMappingURL=ssr.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}